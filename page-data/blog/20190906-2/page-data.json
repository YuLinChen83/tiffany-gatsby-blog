{"componentChunkName":"component---src-templates-post-post-jsx","path":"/blog/20190906-2","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://docs.google.com/presentation/d/1qivdPehhqYPGvXRrHvAknW4PDUp_S04Edo7SPwH0nn0/edit?usp=sharing\" target=\"_blank\" rel=\"nofollow\">分享 PPT</a></p>\n<h2>Hooks</h2>\n<ul>\n<li>有狀態的且會造成副作用的函式（和 Functional programming 相反）</li>\n<li>不寫 React Class component &#x26; this 降低 React 門檻</li>\n<li>可以和 Class component 混用</li>\n</ul>\n<h2>提升性能的 useCallback, useMemo？</h2>\n<ol>\n<li>調用 setState，就會觸發組件的重新渲染（無論前後的 state 是否不同）</li>\n<li>父組件更新，子組件也會自動更新</li>\n<li>\n<p>若 props 為 inline function，每次 render 的時候都會重新生成一個新的函數</p>\n<ul>\n<li>不要用 inline function，將 function 預先定義</li>\n<li>使用 useCallback 或 useMemo 來保存函數的引用，避免重複生成新的函數</li>\n</ul>\n</li>\n</ol>\n<p>優化效能方向：不要觸發 render function、保持 virtual DOM 的一致\n為了改善這種不必要的 re-renders 使用 useCallback／useMemo ：</p>\n<ul>\n<li>並不是使用就一定效能提升</li>\n<li>優化通常有代價，採用前要評估是否利大於弊</li>\n</ul>\n<h2>官方定義</h2>\n<ul>\n<li>\n<h3><a href=\"https://reactjs.org/docs/hooks-reference.html#usecallback\" target=\"_blank\" rel=\"nofollow\">useCallback</a></h3>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">const memoizedCallback = useCallback(() =&gt; {\ndoSomething(a, b);\n}, [a, b]);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>Pass <code>an inline callback</code> and an array of dependencies.</li>\n<li>Returns <code>a memoized callback</code>.</li>\n<li>Optimized child components that rely on reference equality to prevent unnecessary renders (e.g. shouldComponentUpdate).</li>\n<li>若父元件常更新導致子元件 re-render，且若為有 function-prop 的子元件，會使得每次 re-render 都重新 execute 該 function。使用 useCallback 當子元件 prop，可以限定只在 dependency 改變時才 excute，其他時候都會取得 cached function。</li>\n<li>inline functions are slow？Memory and garbage collection</li>\n<li><a href=\"https://react.jokcy.me/book/hooks/hooks-others.html\" target=\"_blank\" rel=\"nofollow\">Source code</a></li>\n</ul>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">export function useCallback&lt;T&gt;(callback: T, inputs: Array&lt;mixed&gt; | void | null): T {\n  currentlyRenderingFiber = resolveCurrentlyRenderingFiber();\n  workInProgressHook = createWorkInProgressHook(); // 返回包含memoizedState的hook對象\n\n  const nextInputs = inputs !== undefined &amp;&amp; inputs !== null ? inputs : [callback]; // 需要保存下來的inputs，用作下次取用的key\n\n  const prevState = workInProgressHook.memoizedState; // 獲取緩存\n  if (prevState !== null) {\n    const prevInputs = prevState[1];\n    if (areHookInputsEqual(nextInputs, prevInputs)) {\n      return prevState[0];\n    }\n  }\n  workInProgressHook.memoizedState = [callback, nextInputs]; // 存入memoizedState以便下次對比使用\n  return callback;\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<h3><a href=\"https://reactjs.org/docs/hooks-reference.html#usememo\" target=\"_blank\" rel=\"nofollow\">useMemo</a></h3>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>Pass <code>a “create” function</code> and an array of dependencies.</li>\n<li>Returns <code>a memoized value</code>.</li>\n<li>If no array is provided, a new value will be computed on every render.</li>\n<li>Helps to avoid <code>expensive calculations</code> on every render.</li>\n<li>如果會造成 side effects 則該使用 useEffect</li>\n<li>和同樣為 16.6.3 發布的 <code>React.memo</code> 不一樣（後面說明）</li>\n<li><a href=\"https://react.jokcy.me/book/hooks/hooks-others.html\" target=\"_blank\" rel=\"nofollow\">Source code</a></li>\n</ul>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">export function useMemo&lt;T&gt;(nextCreate: () =&gt; T, inputs: Array&lt;mixed&gt; | void | null): T {\n  currentlyRenderingFiber = resolveCurrentlyRenderingFiber();\n  workInProgressHook = createWorkInProgressHook(); // 返回包含memoizedState的hook對象\n\n  const nextInputs = inputs !== undefined &amp;&amp; inputs !== null ? inputs : [nextCreate]; // 需要保存下來的inputs，用作下次取用的key\n\n  const prevState = workInProgressHook.memoizedState; // 獲取緩存\n  if (prevState !== null) {\n    const prevInputs = prevState[1];\n    if (areHookInputsEqual(nextInputs, prevInputs)) {\n      return prevState[0];\n    }\n  }\n\n  const nextValue = nextCreate(); // 執行useMemo傳入的第一個參數(函數)\n  workInProgressHook.memoizedState = [nextValue, nextInputs]; // 存入memoizedState以便下次對比使用\n  return nextValue;\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p>當 dependencies 改變才會執行，優化子元件避免不必要的 renders</p>\n<blockquote>\n<p><code>useCallback(fn, deps)</code> is equivalent to <code>useMemo(() => fn, deps)</code>.</p>\n</blockquote>\n<ul>\n<li>\n<h3><a href=\"https://reactjs.org/docs/hooks-reference.html#useref\" target=\"_blank\" rel=\"nofollow\">useRef</a></h3>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">const refContainer = useRef(initialValue);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>常用在訪問子元素的實例</li>\n<li>可以接受一個默認值，並返回一個含有 current 屬性的可變對象</li>\n<li>useRef 會在每次渲染時返回同一個 ref 對象（React.createRef 則是每次創新 ref）</li>\n<li>useRef 就像是可以在其 .current 屬性中保存一個可變值的盒子，渲染週期之間可共享數據的存儲</li>\n</ul>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">function App(props) {\n  const [count, setCount] = useState(0);\n  let it;\n  useEffect(() =&gt; {\n    it = setInterval(() =&gt; {\n      setCount((count) =&gt; count + 1);\n    }, 1000);\n  }, []);\n\n  useEffect(() =&gt; {\n    if (count &gt;= 5) {\n      clearInterval(it); // 經過多次 render 已不是一開始賦予值的 it\n    }\n  });\n\n  return (\n    &lt;div style={{ padding: &#39;100px&#39; }}&gt;\n      &lt;h1&gt;{count}&lt;/h1&gt;\n    &lt;/div&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">function App (props) {\n  const [count, setCount] = useState(0);\n  const it = useRef(null)\n\n  useEffect(() =&gt; {\n    it.current = setInterval(() =&gt; {\n      setCount(count =&gt; count + 1)\n    }, 1000)\n  } , [])\n\n  useEffect(() =&gt; {\n    if (count &gt;= 5) {\n      clearInterval(it.current)\n    }\n  })\n\n  return (\n    ...\n  )\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>可以獲取上次的 props 和 state</li>\n</ul>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">function Counter() {\n  const [count, setCount] = useState(0);\n  const prevCount = usePrevious(count);\n  return (\n    &lt;h1&gt;\n      Now: {count}, before: {prevCount}\n    &lt;/h1&gt;\n  );\n}\n\nfunction usePrevious(value) {\n  const ref = useRef();\n  useEffect(() =&gt; {\n    ref.current = value;\n  });\n  return ref.current;\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<h3><a href=\"https://reactjs.org/docs/hooks-reference.html#useimperativehandle\" target=\"_blank\" rel=\"nofollow\">useImperativeHandle</a></h3>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">useImperativeHandle(ref, createHandle, [deps]);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>用於自定義暴露給父組件的 ref 屬性</li>\n<li>需要配合 forwardRef 一起使用</li>\n<li>In this example, a parent component that renders <code>&#x3C;FancyInput ref={fancyInputRef} /></code> would be able to call <code>fancyInputRef.current.focus()</code>.</li>\n</ul>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">// 子元件\nfunction FancyInput(props, ref) {\n  const inputRef = useRef();\n  useImperativeHandle(ref, () =&gt; ({\n    focus: () =&gt; {\n      inputRef.current.focus();\n    }\n  }));\n  return &lt;input ref={inputRef} ... /&gt;;\n}\nFancyInput = forwardRef(FancyInput);</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">// 父组件\nimport React, { useRef } from &#39;react&#39;;\nfunction App() {\n  const fancyInputRef = useRef(null);\n  // 獲取子元件暴露的方法\n  fancyInputRef.current.focus();\n  return (\n    &lt;div&gt;\n      &lt;FancyInput ref={fancyInputRef} /&gt;\n    &lt;/div&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<hr>\n<h4>補充：Memoization</h4>\n<ul>\n<li>\n<p><code>Memoization</code> 是 JavaScript 中通過緩存結果並在下一個操作中重新使用緩存來加速查找費時的操作（像建表查表）</p>\n<ul>\n<li>以空間換速度</li>\n<li>Pure function 適用</li>\n<li>相同的輸入，必定拿到相同的輸出（沒有任何副作用）</li>\n<li>可移植、可測試、可緩存</li>\n<li>舉例：javascript 的 slice 是，但 splice 不是</li>\n<li>\n<p>Curry、Compose 也是 Pure function 應用</p>\n<ul>\n<li>Curry（parital application 或 partial evaluation）\n將一個接受 n 個參數的 function，轉變成 n 個只接受一個參數的 function 的過程</li>\n<li>Partial Function Application\n和 curry 不同的是一個函式可能會接收超過一個以上的參數</li>\n<li>Compose\n能把多的參數組合在一起，產生一個新的 function</li>\n</ul>\n</li>\n<li>\n<p>Functional Programming（FP）</p>\n<ul>\n<li>一種編程範式(programming paradigm)，就像 Object-oriented Programming(OOP)一樣，就是一種寫程式的方法論</li>\n<li>把函式當成參數傳入，並以沒有 side effect 的方式回傳另一個函式</li>\n<li>都是 表達式 (Expression) 不會是 陳述式(Statement)</li>\n<li>可讀性高、可維護性高、易於平行處理</li>\n<li>rx 的重要觀念</li>\n<li>衍伸出 Pure Function、Currying、Higher-Order Function</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4>補充：React.memo</h4>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">const Demo = React.memo(\n  ({ children }) =&gt; &lt;div&gt;{children}&lt;/div&gt;,\n  (prevProps, nextProps) =&gt; {\n    /*\n     return true if passing nextProps to render would return\n     the same result as passing prevProps to render,\n     otherwise return false\n    */\n\n    return false;\n  }\n);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>不是 React.useMemo</li>\n<li>high Order Component</li>\n<li>\n<p>可以用 functional component 實現 <code>shouldComponentUpdate</code>／<code>PureComponent</code></p>\n<ul>\n<li>PureComponent：會自動進行 <a href=\"https://hackmd.io/JZ7CjfG1Sjap68_s00F8CA?view#%E8%A3%9C%E5%85%85%EF%BC%9AShallow-compare\" target=\"_blank\" rel=\"nofollow\">shallow equal</a> 比對進行 re-render</li>\n</ul>\n</li>\n<li>\n<p>functional component 可以使用 <code>React.memo(Component, areEqual)</code> 來改寫。<code>areEqual</code> 取代 <code>shouldComponentUpdate</code></p>\n<ul>\n<li>注意 return 的 boolean 代表意義不同</li>\n</ul>\n</li>\n<li>第二個參數可像 shouldComponentUpdate 自定義判斷更新條件，但仍要注意考量函數的性能開銷。如果道具對象過深，反而會消耗不少的性能。</li>\n</ul>\n<h4>補充：PureComponent</h4>\n<ul>\n<li>每次都會進行 shallow compare ，而 Component 則不會，所以誤用有可能反而效能更差</li>\n<li>傳入的 props 或 state 不可以有每次都會變動的值，不然其實和 Component 沒兩樣</li>\n<li>不能使用 shouldComponentUpdate</li>\n<li>最好作為展示組件</li>\n</ul>\n<h4>補充：一致性比較：Reconciliation 協調</h4>\n<p>React 每次 render() 都會做 Diffing 比對根元素、Reconciliation 更新 DOM</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">// 子元素末尾添加一個元素\n&lt;ul&gt;\n  &lt;li&gt;first&lt;/li&gt;\n  &lt;li&gt;second&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;ul&gt;\n  &lt;li&gt;first&lt;/li&gt;\n  &lt;li&gt;second&lt;/li&gt;\n  &lt;li&gt;third&lt;/li&gt;\n&lt;/ul&gt;</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">// 開始處插入一個節點 -&gt; 性能就不佳\n&lt;ul&gt;\n  &lt;li&gt;Duke&lt;/li&gt;\n  &lt;li&gt;Villanova&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;ul&gt;\n  &lt;li&gt;Connecticut&lt;/li&gt;\n  &lt;li&gt;Duke&lt;/li&gt;\n  &lt;li&gt;Villanova&lt;/li&gt;\n&lt;/ul&gt;</code>\n        </deckgo-highlight-code>\n<p>所以加 <code>key</code> 讓 React 得以比對出哪些是新的該創、舊的該卸載、現有的僅作移動。但不要用 index 當 key：當索引用作 key 時，組件狀態在重新排序時也會有問題。組件實例基於 key 進行更新和重用。如果 key 是索引，則 item 的順序變化會改變 key 值。這將導致受控組件的狀態可能會以意想不到的方式混淆和更新。</p>\n<h4>補充：Shallow compare</h4>\n<ul>\n<li>採用嚴格相等（Strict Equality Comparison）：\n對於基本型別 (number, string, boolean, null, undefined, symbol)，值必須要完全相等；\n對於物件型別 (object, array, function)，必須指向同一個 reference。\n<img src=\"https://i.imgur.com/18p9agH.png\"></li>\n<li>只比到第一層</li>\n<li>\n<p>所以有可能發生：</p>\n<ol>\n<li>值不一樣，但因為 reference 一樣所以回 true 不更新不 render</li>\n<li>值一樣，但因為 reference 不同所以回 false 而更新</li>\n</ol>\n</li>\n</ul>\n<h4>補充：父組件獲取子組件數據的 3 種方式 <a href=\"https://codesandbox.io/embed/focused-star-gwvlo\" target=\"_blank\" rel=\"nofollow\">Example</a></h4>\n<ol>\n<li>createRef</li>\n<li>useRef + forwardRef</li>\n<li>useImperativeHandle + forwardRef + useRef</li>\n</ol>","timeToRead":8,"frontmatter":{"title":"React Hooks - useCallback, useMemo, useRef","date":"06 Sep 2019","tags":["reactjs"],"path":"blog/20190906-2","excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"blog/20210725","title":"初試 SonarQube","tags":["tool"],"excerpt":"記錄下認識的新東西。"}}},{"node":{"frontmatter":{"path":"blog/20220206","title":"淺入淺出 Service Worker","tags":["javascript"],"excerpt":"簡單紀錄下關於 PWA 與 Service Worker 的觀點與主要功能。"}}},{"node":{"frontmatter":{"path":"blog/20210725-2","title":"SVGR 設置","tags":["javascript"],"excerpt":"webpack loader 以 Component 方式使用 Svg。"}}},{"node":{"frontmatter":{"path":"blog/20210110","title":"Pop Quiz","tags":["javascript"],"excerpt":"記錄踩到的陷阱題。"}}},{"node":{"frontmatter":{"path":"blog/20210109-3","title":"REST / RESTful & HTTP Methods","tags":["javascript"],"excerpt":"簡易整理。"}}},{"node":{"frontmatter":{"path":"blog/20210109","title":"Response Set-Cookie 無效","tags":["apollo"],"excerpt":"記錄個之前在和同事們弄 Side project 時犯蠢遇到的問題與解決方式。"}}},{"node":{"frontmatter":{"path":"blog/20200910","title":"Apollo Server 入門篇","tags":["apollo"],"excerpt":"快速複習去年分享的 GraphQL Schema 和 Client query 語法，並簡介如何以 Apollo Server 建立 GraphQL Server。"}}},{"node":{"frontmatter":{"path":"blog/20210109-2","title":"IntersectionObserver","tags":["javascript"],"excerpt":"公司專案有個日期連動的 scroll 優化試驗，原先是監聽 scroll。"}}},{"node":{"frontmatter":{"path":"blog/20190909","title":"Prisma - Schema, Data Model, Relations, Client","tags":["prisma"],"excerpt":"未來 Side project 可能會應用到的 SDL first 開發流程角度，簡介此可以取代傳統 ORM 的 DB toolkit。"}}},{"node":{"frontmatter":{"path":"blog/20200630","title":"Express - Authentication, Authorization and Security","tags":["security","express"],"excerpt":"簡介 Express RESTful API Server 範例中 JWT 權限、授權相關。"}}},{"node":{"frontmatter":{"path":"blog/20200518","title":"常用 NoSQL 雲端資料庫 - Part 1 MongoDB","tags":["mongodb"],"excerpt":"簡介 Relational/NoSQL database、mongoose ORM 寫 mongo CRUD API。"}}},{"node":{"frontmatter":{"path":"blog/20200527","title":"常用 NoSQL 雲端資料庫 - Part 2 Firebase","tags":["firebase"],"excerpt":"簡介 Google 提供的後端服務平臺（BaaS）中的兩種 DB，realtime database 和 cloud firestore。"}}},{"node":{"frontmatter":{"path":"blog/20191107","title":"Javascript Event loop - macro task & micro task","tags":["javascript"],"excerpt":"介紹 Event loop 容易混淆的異步任務 macro task & micro task。"}}},{"node":{"frontmatter":{"path":"blog/20191125","title":"初探 RxJS（下）","tags":["rxjs"],"excerpt":"簡介上次未完的 RxJS 剩餘角色，和介紹目前公司後台專案使用的 redux-observable。"}}},{"node":{"frontmatter":{"path":"blog/20191017","title":"初探 RxJS（上）","tags":["rxjs"],"excerpt":"簡介相關的設計模式中的 Behavioral Pattern，再介紹 RxJS（先講 Observable）"}}},{"node":{"frontmatter":{"path":"blog/20190907","title":"GraphQL & Apollo Client","tags":["apollo"],"excerpt":"簡單介紹 React Client 端如何用 Apollo 對 GraphQL Server 做資料存取操作。"}}},{"node":{"frontmatter":{"path":"blog/20190906","title":"初探 Storybook","tags":["javascript"],"excerpt":"初探這款能夠在開發前端元件或是函式庫的同時，可以快速地建立元件各種操作模式或是樣式的工具。"}}},{"node":{"frontmatter":{"path":"blog/20190707","title":"JavaScript HTML5 Web Worker & CRA 使用踩雷","tags":["javascript"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20180521","title":"Web 常見攻擊手法","tags":["security"],"excerpt":"擁有基本的資安觀念保護好自家資料和 user 使用環境是開發人員重要的一點。"}}},{"node":{"frontmatter":{"path":"blog/20180514","title":"JavaScript 中 this 指向","tags":["javascript"],"excerpt":"簡介 this 指向的六種情況。"}}},{"node":{"frontmatter":{"path":"blog/20190108","title":"JavaScript 認識非同步 Callback, Promise, async/await","tags":["javascript"],"excerpt":"Asynchronous 非同步的不同寫法的整理筆記。"}}},{"node":{"frontmatter":{"path":"blog/20170714","title":"WebForm 使用 reCAPTCHA 驗證","tags":["asp.net"],"excerpt":"這個我不是機器人驗證一定不陌生，滿多登入畫面會看到的，剛好今天接到把圖形驗證改為 reCAPTCHA 就順手記下。"}}},{"node":{"frontmatter":{"path":"blog/20170728","title":"WebForm 註冊 JavaScript","tags":["asp.net","javascript"],"excerpt":"動態產生JS在目前公司專案中是滿常用到的小技巧，不同的用法會產生在Web Page 的不同位置而有直譯式語言的前後順序差。"}}},{"node":{"frontmatter":{"path":"blog/20170604","title":"Web App 推播通知","tags":["asp.net"],"excerpt":"隨著行動和穿載裝置的興起，推播通知 (Push Notification) 成為維繫App用戶關係相當有力的工具"}}},{"node":{"frontmatter":{"path":"blog/20170508","title":"WebForm 圖片上傳檢查","tags":["asp.net"],"excerpt":"開放上傳有可能被傳奇怪東西的風險，只檢查所看到的副檔名，謹慎來說似乎是不夠的。"}}},{"node":{"frontmatter":{"path":"blog/20170421","title":"存取遠端 EventLog","tags":["asp.net","javascript"],"excerpt":"在公司中實作一個 Event log 的查詢工具。（之後來寫了 D3 呈現查詢異常查詢的部分）"}}}]}},"pageContext":{"postPath":"blog/20190906-2","translations":[{"hreflang":"en","path":"/blog/20190906-2"}]}},"staticQueryHashes":["4097791827"]}