{"componentChunkName":"component---src-templates-post-post-jsx","path":"/blog/20191107","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://hackmd.io/mU49WAgDSVWvcSB6n8vmmA?view\" target=\"_blank\" rel=\"nofollow\">Hackmd</a></p>\n<p><img src=\"https://i.imgur.com/PqEj2tf.png\"></p>\n<ul>\n<li>JavaScript 是單線程，瀏覽器中主執行緒擁有一個 執行棧（execution context stack／call stack） 以及一個 任務佇列（task queue／callback queue）</li>\n<li>\n<p>所有任務可分為同步任務（synchronous）或異步任務（asynchronous）</p>\n<ul>\n<li>同步任務都在主線程上執行，形成一個<strong>執行棧 execution context stack</strong></li>\n<li>異步任務指當運行有結果，就在<strong>任務隊列 callback queue</strong> 之中放置一個事件，等待丟到 stack 進入主線程執行</li>\n<li>當 stack 中所有同步任務執行完畢，才會讀取 task queue 任務丟進 stack 執行</li>\n<li>\n<p>queue 中異步任務還區分成 <code>macro task</code> 跟 <code>micro task</code> 兩種，在 ECMAScript 中，microtask 微任務又稱為 job，macrotask 就 task</p>\n<ul>\n<li><strong>macrotasks</strong>（通常指一般的 task）\nsetTimeout, setInterval, setImmediate, I/O, UI rendering\n一次只會入棧一個執行</li>\n<li><strong>microtasks</strong>（job）\nprocess.nextTick, Promises, Object.observe(廢棄), MutationObserver\n會一次入棧並執行完所有 microtasks</li>\n<li>ps. <strong>在 node 環境下</strong>，process.nextTick 的優先順序高於 Promise</li>\n</ul>\n</li>\n<li>\n<p>瀏覽器為了能夠使得 JS 內部 task 與 DOM 任務能夠有序的執行，會在一個 task（這邊指 macro task）執行結束後、下一個 task 執行開始前，對頁面進行重新渲染<br>\n<code>task → 渲染 → task → ...</code><br>\n白話說明(?)：</p>\n<blockquote>\n<ol>\n<li>遇到同步直接執行</li>\n<li>遇到異步的 macro task 丟進 callback queue 再繼續向下執行</li>\n<li>遇到異步的 micro task 會丟到特別的 job queue 等同步執行完、該丟的 macro task 丟到 callback queue 後，再回來處理並清空這次 job queue 累積的 micro task</li>\n<li>job queue 空了再執行剛 2. 丟到 callback queue 的 macro task</li>\n<li>頁面渲染</li>\n</ol>\n</blockquote>\n<div class=\"warning\">\n在每一次事件循環中，只會入棧一個 macrotask 執行，主線程執行完該任務後又會先檢查 microtasks 隊列並完成裡面的所有任務後再執行 macrotask\n→ 不斷偵測 call stack 是否為空，如果是空的話就把 callback queue 裡面的東西丟到 call stack\n</div>\n</li>\n</ul>\n</li>\n</ul>\n<h3>Question 1.</h3>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">console.log(&#39;script start&#39;);\nsetTimeout(function() {\n  console.log(&#39;setTimeout&#39;);\n}, 0);\nPromise.resolve()\n  .then(function() {\n    console.log(&#39;promise1&#39;);\n  })\n  .then(function() {\n    console.log(&#39;promise2&#39;);\n  });\nconsole.log(&#39;script end&#39;);</code>\n        </deckgo-highlight-code>\n<h3>Question 2.</h3>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">a(function() {\n  console.log(&#39;a&#39;);\n});\nconsole.log(&#39;hello&#39;);</code>\n        </deckgo-highlight-code>\n<p>不一定，因為沒說 a 是同步還是非同步</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">function a(fn) {\n  fn(); // 同步執行 fn\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">function a(fn) {\n  setTimeout(fn, 0); // 非同步執行 fn\n}</code>\n        </deckgo-highlight-code>\n<h3>Question 3.</h3>\n<p>提示：setInterval、setTimeout 是 macro task；Promise 是 micro task<br>\n想想並先將自己答案記起來，3 分鐘作答～</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">console.log(&#39;start&#39;);\n\nconst interval = setInterval(() =&gt; {\n  console.log(&#39;setInterval&#39;);\n}, 0);\n\nsetTimeout(() =&gt; {\n  console.log(&#39;setTimeout 1&#39;);\n  Promise.resolve()\n    .then(() =&gt; {\n      console.log(&#39;promise 3&#39;);\n    })\n    .then(() =&gt; {\n      setTimeout(() =&gt; {\n        console.log(&#39;setTimeout 2&#39;);\n        Promise.resolve()\n          .then(() =&gt; {\n            console.log(&#39;promise 4&#39;);\n          })\n          .then(() =&gt; {\n            clearInterval(interval);\n            console.log(&#39;clearInterval&#39;);\n          });\n      }, 0);\n      Promise.resolve().then(() =&gt; {\n        console.log(&#39;promise 7&#39;);\n      });\n    });\n}, 0);\n\nPromise.resolve()\n  .then(() =&gt; {\n    console.log(&#39;promise 1&#39;);\n  })\n  .then(() =&gt; {\n    console.log(&#39;promise 2&#39;);\n  });\n\nconsole.log(&#39;end&#39;);</code>\n        </deckgo-highlight-code>\n<h3>Question 4.</h3>\n<p>提示：setTimeout 是 macro task；MutationObserver、Promise 是 micro task</p>\n<ol>\n<li>在 outer click？</li>\n<li>在 inner click？ (event bubbles)</li>\n</ol>\n<deckgo-highlight-code html  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">&lt;div class=&quot;outer&quot;&gt;\n  &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">var outer = document.querySelector(&#39;.outer&#39;);\nvar inner = document.querySelector(&#39;.inner&#39;);\n\n// 監聽 outer element 當 attribute changes 時觸發\nnew MutationObserver(function() {\n  console.log(&#39;mutate&#39;);\n}).observe(outer, {\n  attributes: true,\n});\n\nfunction onClick() {\n  console.log(&#39;click&#39;);\n\n  setTimeout(function() {\n    console.log(&#39;timeout&#39;);\n  }, 0);\n\n  Promise.resolve().then(function() {\n    console.log(&#39;promise&#39;);\n  });\n\n  outer.setAttribute(&#39;data-random&#39;, Math.random());\n}\n\ninner.addEventListener(&#39;click&#39;, onClick);\nouter.addEventListener(&#39;click&#39;, onClick);</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\" target=\"_blank\" rel=\"nofollow\">看視覺化的流程</a></p>\n<h2>References</h2>\n<ul>\n<li><a href=\"https://blog.huli.tw/2019/10/04/javascript-async-sync-and-callback/index.html?fbclid=IwAR18LUDiosggPZnp7XaylPGDD2zoyRdd9SnwvlrO4zDgkBpwypBdcKUlXyc\" target=\"_blank\" rel=\"nofollow\">JavaScript 中的同步與非同步（上）：先成為 callback 大師吧！</a></li>\n<li><a href=\"https://www.itread01.com/content/1548614167.html\" target=\"_blank\" rel=\"nofollow\">event loop js 事件迴圈 microtask macrotask</a></li>\n<li><a href=\"https://www.jishuwen.com/d/25jF/zh-tw\" target=\"_blank\" rel=\"nofollow\">聊聊 JavaScript 非同步中的 macrotask 和 microtask</a></li>\n<li>\n<p><a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\" target=\"_blank\" rel=\"nofollow\">Tasks, microtasks, queues and schedules</a></p>\n<ul>\n<li>有簡單的例子還以易懂的視覺化呈現可參考</li>\n</ul>\n</li>\n<li><a href=\"https://youtu.be/8aGhZQkoFbQ\" target=\"_blank\" rel=\"nofollow\">What the heck is the event loop anyway? | Philip Roberts | JSConf EU</a></li>\n</ul>","timeToRead":4,"frontmatter":{"title":"Javascript Event loop - macro task & micro task","date":"07 Nov 2019","tags":["javascript"],"path":"blog/20191107","excerpt":"介紹 Event loop 容易混淆的異步任務 macro task & micro task。"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"blog/20210725","title":"初試 SonarQube","tags":["tool"],"excerpt":"記錄下認識的新東西。"}}},{"node":{"frontmatter":{"path":"blog/20220206","title":"淺入淺出 Service Worker","tags":["javascript"],"excerpt":"簡單紀錄下關於 PWA 與 Service Worker 的觀點與主要功能。"}}},{"node":{"frontmatter":{"path":"blog/20210725-2","title":"SVGR 設置","tags":["javascript"],"excerpt":"webpack loader 以 Component 方式使用 Svg。"}}},{"node":{"frontmatter":{"path":"blog/20210110","title":"Pop Quiz","tags":["javascript"],"excerpt":"記錄踩到的陷阱題。"}}},{"node":{"frontmatter":{"path":"blog/20210109-3","title":"REST / RESTful & HTTP Methods","tags":["javascript"],"excerpt":"簡易整理。"}}},{"node":{"frontmatter":{"path":"blog/20210109","title":"Response Set-Cookie 無效","tags":["apollo"],"excerpt":"記錄個之前在和同事們弄 Side project 時犯蠢遇到的問題與解決方式。"}}},{"node":{"frontmatter":{"path":"blog/20200910","title":"Apollo Server 入門篇","tags":["apollo"],"excerpt":"快速複習去年分享的 GraphQL Schema 和 Client query 語法，並簡介如何以 Apollo Server 建立 GraphQL Server。"}}},{"node":{"frontmatter":{"path":"blog/20210109-2","title":"IntersectionObserver","tags":["javascript"],"excerpt":"公司專案有個日期連動的 scroll 優化試驗，原先是監聽 scroll。"}}},{"node":{"frontmatter":{"path":"blog/20190909","title":"Prisma - Schema, Data Model, Relations, Client","tags":["prisma"],"excerpt":"未來 Side project 可能會應用到的 SDL first 開發流程角度，簡介此可以取代傳統 ORM 的 DB toolkit。"}}},{"node":{"frontmatter":{"path":"blog/20200630","title":"Express - Authentication, Authorization and Security","tags":["security","express"],"excerpt":"簡介 Express RESTful API Server 範例中 JWT 權限、授權相關。"}}},{"node":{"frontmatter":{"path":"blog/20200518","title":"常用 NoSQL 雲端資料庫 - Part 1 MongoDB","tags":["mongodb"],"excerpt":"簡介 Relational/NoSQL database、mongoose ORM 寫 mongo CRUD API。"}}},{"node":{"frontmatter":{"path":"blog/20200527","title":"常用 NoSQL 雲端資料庫 - Part 2 Firebase","tags":["firebase"],"excerpt":"簡介 Google 提供的後端服務平臺（BaaS）中的兩種 DB，realtime database 和 cloud firestore。"}}},{"node":{"frontmatter":{"path":"blog/20191125","title":"初探 RxJS（下）","tags":["rxjs"],"excerpt":"簡介上次未完的 RxJS 剩餘角色，和介紹目前公司後台專案使用的 redux-observable。"}}},{"node":{"frontmatter":{"path":"blog/20191017","title":"初探 RxJS（上）","tags":["rxjs"],"excerpt":"簡介相關的設計模式中的 Behavioral Pattern，再介紹 RxJS（先講 Observable）"}}},{"node":{"frontmatter":{"path":"blog/20190907","title":"GraphQL & Apollo Client","tags":["apollo"],"excerpt":"簡單介紹 React Client 端如何用 Apollo 對 GraphQL Server 做資料存取操作。"}}},{"node":{"frontmatter":{"path":"blog/20190906","title":"初探 Storybook","tags":["javascript"],"excerpt":"初探這款能夠在開發前端元件或是函式庫的同時，可以快速地建立元件各種操作模式或是樣式的工具。"}}},{"node":{"frontmatter":{"path":"blog/20190906-2","title":"React Hooks - useCallback, useMemo, useRef","tags":["reactjs"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20190707","title":"JavaScript HTML5 Web Worker & CRA 使用踩雷","tags":["javascript"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20180521","title":"Web 常見攻擊手法","tags":["security"],"excerpt":"擁有基本的資安觀念保護好自家資料和 user 使用環境是開發人員重要的一點。"}}},{"node":{"frontmatter":{"path":"blog/20180514","title":"JavaScript 中 this 指向","tags":["javascript"],"excerpt":"簡介 this 指向的六種情況。"}}},{"node":{"frontmatter":{"path":"blog/20190108","title":"JavaScript 認識非同步 Callback, Promise, async/await","tags":["javascript"],"excerpt":"Asynchronous 非同步的不同寫法的整理筆記。"}}},{"node":{"frontmatter":{"path":"blog/20170714","title":"WebForm 使用 reCAPTCHA 驗證","tags":["asp.net"],"excerpt":"這個我不是機器人驗證一定不陌生，滿多登入畫面會看到的，剛好今天接到把圖形驗證改為 reCAPTCHA 就順手記下。"}}},{"node":{"frontmatter":{"path":"blog/20170728","title":"WebForm 註冊 JavaScript","tags":["asp.net","javascript"],"excerpt":"動態產生JS在目前公司專案中是滿常用到的小技巧，不同的用法會產生在Web Page 的不同位置而有直譯式語言的前後順序差。"}}},{"node":{"frontmatter":{"path":"blog/20170604","title":"Web App 推播通知","tags":["asp.net"],"excerpt":"隨著行動和穿載裝置的興起，推播通知 (Push Notification) 成為維繫App用戶關係相當有力的工具"}}},{"node":{"frontmatter":{"path":"blog/20170508","title":"WebForm 圖片上傳檢查","tags":["asp.net"],"excerpt":"開放上傳有可能被傳奇怪東西的風險，只檢查所看到的副檔名，謹慎來說似乎是不夠的。"}}},{"node":{"frontmatter":{"path":"blog/20170421","title":"存取遠端 EventLog","tags":["asp.net","javascript"],"excerpt":"在公司中實作一個 Event log 的查詢工具。（之後來寫了 D3 呈現查詢異常查詢的部分）"}}}]}},"pageContext":{"postPath":"blog/20191107","translations":[{"hreflang":"en","path":"/blog/20191107"}]}},"staticQueryHashes":["4097791827"]}