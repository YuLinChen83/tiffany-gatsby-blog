{"componentChunkName":"component---src-templates-post-post-jsx","path":"/blog/20200910","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://hackmd.io/mOTKzMwoRyaDvP2NkyV6MQ?view\" target=\"_blank\" rel=\"nofollow\">HackMD</a></p>\n<h1>GraphQL Server</h1>\n<h2>先前開發 Server 的演變概要：<a href=\"https://github.com/prisma-labs/graphql-yoga\" target=\"_blank\" rel=\"nofollow\">GraphQL Yoga</a> 🔜 <a href=\"https://www.apollographql.com/docs/apollo-server/\" target=\"_blank\" rel=\"nofollow\">Apollo Server</a></h2>\n<ul>\n<li>社群大小、活躍度、使用者多寡</li>\n<li>\n<p>考量未來可能會有使用 Federation 的場景 <a href=\"https://chihching.net/intro-graphql-federation-zh-hant\" target=\"_blank\" rel=\"nofollow\">Federation 可以參考這篇</a></p>\n<ul>\n<li>後端想要不同 microservice 處理他們各自的邏輯，各自維護負責範圍的 Schema</li>\n</ul>\n</li>\n</ul>\n<h2>GraphQL Schema</h2>\n<p>定義 GraphQL API 的輪廓及規範，當與 Resolver 處理出的資料不符合 Type 就會噴錯（但 Null 可以通過）<br>\n快速複習常用的定義 Schema 用法：</p>\n<ul>\n<li>\n<p>Object type</p>\n<ul>\n<li>包含 fields 和 field 的 type</li>\n</ul>\n<deckgo-highlight-code graphql  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">#################### Type ###################\ntype User {\n  lastName: String\n  firstName: String\n  birthday: Date\n  createdAt: Date\n  updatedAt: Date\n}\n\n#################### Root ###################\ntype Query {\n  user(id: ID!): User\n}\n\ntype Mutation {\n  createUser(data: UserCreateInput!): User\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>Query、Mutation、Subscription 也是，但同時也是 Schema 的 entry point</li>\n</ul>\n</li>\n<li>\n<p>Input Object Type\n跟 Object Type 幾乎一樣的還有 Input Object Type，但是一個是傳入 Argument 作為 Input（只會在左邊） ，一個是用於資料索取展示</p>\n<ul>\n<li>推薦每支 mutation 都新增一支專屬的 input object type，習慣命名 xxxInput</li>\n</ul>\n</li>\n<li>\n<p>Scalar Type (Int, Float, String, Boolean, ID, Enum)</p>\n<ul>\n<li>\n<p>Enum</p>\n<deckgo-highlight-code graphql  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">enum Sort {\nasc\ndesc\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>其他例如 Date、Timestamp 都要另外自定義</li>\n</ul>\n</li>\n<li>\n<p>Non-null Syntax</p>\n<ul>\n<li>type 右邊加上 <code>!</code> 保證不為空</li>\n<li>一旦修改 Not-Null field 就會是 Breaking Change，建議剛開始設計時，除了 ID 以外的欄位都不要加上</li>\n</ul>\n</li>\n<li>\n<p>Array Type Syntax</p>\n<ul>\n<li>用 <code>[]</code> 包起來就是 array type</li>\n<li>例如：<code>notIn: [Int]</code>、<code>teachers: [User]</code>、<code>courses: [Course]</code></li>\n<li>有無加上 Non-null Syntax 舉例：</li>\n<li><code>teachers: [User]</code></li>\n<li><code>teachers: [User!]</code></li>\n<li><code>teachers: [User!]!</code></li>\n</ul>\n</li>\n<li>不管是 Object Type 或 Scalar Type 都能使用 Argument</li>\n<li>\n<p>註解：</p>\n<ul>\n<li>單行出現在文件 <code>\"</code></li>\n<li>單行不出現在文件 <code>#</code></li>\n<li>多行出現在文件 <code>\"\"\"</code></li>\n</ul>\n</li>\n</ul>\n<h2>組成</h2>\n<h3>1. Create an instance of ApolloServer</h3>\n<ul>\n<li>\n<p><code>new ApolloServer({ typeDefs, resolvers }</code> 最基本要傳 typeDefs、 resolvers，但我們還需要透過 context 來放 prisma client：</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">// server.js\nconst { ApolloServer } = require(&#39;apollo-server&#39;);\nconst dotenv = require(&#39;dotenv/config&#39;);\nconst { createContext } = require(&#39;./context&#39;);\nconst { typeDefs } = require(&#39;./typeDefs&#39;);\nconst { resolvers } = require(&#39;./resolvers&#39;);\n\nconst server = new ApolloServer({ typeDefs, resolvers, context: createContext });\nserver.listen().then(({ url }) =&gt; {\nconsole.log(`🚀  Server ready at ${url}`);\n});</code>\n        </deckgo-highlight-code>\n<ul>\n<li>起起來的預設 port 就是 GraphQL Playground，可以在這邊確認文件、試打 api 符不符合自己的預期</li>\n</ul>\n</li>\n<li>\n<p><code>context</code> 主要都是放 request/response、ORM、處理認證等相關的東西，得以在每個 resolver 使用（又有點像 middleware）</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">// context.js\nconst { PrismaClient } = require(&#39;@prisma/client&#39;);\nconst jwt = require(&#39;jsonwebtoken&#39;);\nconst prisma = new PrismaClient();\n\nconst parseCookie = (str = &#39;&#39;) =&gt;\nstr\n  ? str\n      .split(&#39;;&#39;)\n      .map((v) =&gt; v.split(&#39;=&#39;))\n      .reduce((acc, v) =&gt; {\n        acc[decodeURIComponent(v[0].trim())] = decodeURIComponent(v[1].trim());\n        return acc;\n      }, {})\n  : {};\n\nasync function createContext({ req, res }) {\nconst cookies = parseCookie(req.headers.cookie);\nconst { accessToken, refreshToken } = cookies;\nconst context = {\n  request: req,\n  response: res,\n  prisma,\n};\nlet decoded = await jwt.decode(accessToken, process.env.ACCESS_TOKEN_SECRET);\nif (!decoded) {\n  if (refreshToken) {\n    context.currentUser = decoded || null;\n  }\n}\nreturn context;\n}\n\nmodule.exports = {\ncreateContext,\n};</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p><code>typeDefs</code> 定義 Schema (Query, Mutation, Type, Input object ...)</p>\n<ul>\n<li>Query, Mutation 其實就是定義 field 或 function name 被 call 時的 ==input, output 格式==，格式就是預設的 scalar type 或是自己定義的 type, input object, enum...等等，真正邏輯實作在與其 name 對應的 resolver</li>\n</ul>\n</li>\n<li><code>resolvers</code> 依據定義的 Query, Mutation Schema 的資料操作、邏輯等實作（名稱要對上）</li>\n<li><a href=\"https://stackoverflow.com/a/60747952/7849574\" target=\"_blank\" rel=\"nofollow\">typeDefs, resolvers 拆分參考</a>\ntypeDefs 可以給陣列\nresolvers 可以在另外解構合併成一大包</li>\n</ul>\n<h3>2. typeDefs</h3>\n<ul>\n<li>透過 <code>apollo-server</code> 的 gql 寫 graph schema，一個 typeDefs 物件裡通常一定會有 type Query 和 type Mutation，裡面再定義要經過 resolver 處理的 field 或 function 的名稱、輸入型別、輸出型別（詳細寫法請參閱 <a href=\"https://graphql.org/learn/\" target=\"_blank\" rel=\"nofollow\">GraphQL 官方文件</a>）</li>\n<li>\n<p>在定義 type 時，field name 要對照 DB 實際的 Table column name ，依我們 prisma 映射 DB 的專案可以直接參照檔案 <code>schema.prisma</code>（我們 MySQL DB 中的 Tables 就是下 <code>npx prisma migrate save --experimental</code>、<code>npx prisma migrate up --experimental</code>，然後依據這檔案建立/修改的）\n舉例：</p>\n<ol>\n<li>schema.prisma 有定義一個會產生 user table 的 data model</li>\n</ol>\n<deckgo-highlight-code json  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">      model User {\n  id             Int              @default(autoincrement()) @id\n  email          String           @unique\n  password       String\n  lastName       String           @map(name: &quot;last_name&quot;)\n  firstName      String           @map(name: &quot;first_name&quot;)\n  nickName       String           @map(name: &quot;nick_name&quot;)\n  birthday       DateTime?\n  headThumb      String?          @map(name: &quot;head_thumb&quot;)\n  desc           String?\n  notified       Boolean          @default(false)\n  activated      Boolean          @default(false)\n  facebookId     String?          @map(name: &quot;facebook_id&quot;)\n  googleId       String?          @map(name: &quot;google_id&quot;)\n  createdAt      DateTime         @map(name: &quot;created_at&quot;)  @default(now())\n  updatedAt      DateTime?        @map(name: &quot;updated_at&quot;)  @updatedAt\n  courses        Course[]\n\n  @@map(name: &quot;user&quot;)\n}</code>\n        </deckgo-highlight-code>\n<ol start=\"2\">\n<li>然後在 typeDefs 定義一個 user 的 crud 輪廓，依據有無資料異動分到 type Query（無資料異動，通常 camelCase 名詞）/ type Mutation（有資料異動，通常 camelCase 動詞+名詞）底下。宣告 Type 類型的名稱習慣 PascalCase 名詞。</li>\n<li>當要傳很多值的話，通常會宣告一個傳 input object type 的參數（負責新增的 input 傳的參數我們統一叫 <code>data</code> 好了），會依據不同操作定義不同的 <code>input XxxxInput</code>，當中字段可能就會包含 Create/Update/Update...。例如：<code>signUp(data: UserCreateInput!): User</code>\n這些傳的參數很大包的話通常在 client query 就會宣告變數、input object 傳的整包另外被放在 Query Variables（playground 範例）</li>\n<li>\n<p>另外提醒適當的註解有助於更完整 Schema 及文件的說明，可以多多利用</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">        const { gql } = require(&#39;apollo-server&#39;);\nconst typeDefs = gql`\n##################### Common 共用 ###################\nscalar DateTime\nscalar Date\n\n      enum Gender {\n        &quot;Male&quot;\n        M\n        &quot;Female&quot;\n        F\n        &quot;TRANSGENDER&quot;\n        T\n      }\n\n      enum Sort {\n        asc\n        desc\n      }\n\n      &quot;&quot;&quot;\n      共用表格filter保留字參數\n      &quot;&quot;&quot;\n      input TableStringFilterInput {\n        ne: String\n        eq: String\n        le: String\n        lt: String\n        ge: String\n        gt: String\n        contains: String\n        notContains: String\n        between: [String]\n        beginsWith: String\n      }\n      input TableIntFilterInput {\n        equals: Int\n        not: Int\n        in: Int\n        notIn: [Int]\n        lt: Int\n        lte: Int\n        ge: Int\n        gte: Int\n      }\n\n      ##################### User 使用者 ###################\n      &quot;&quot;&quot;\n      建立使用者參數\n      &quot;&quot;&quot;\n      input UserCreateInput {\n        email: String!\n        password: String!\n        lastName: String!\n        firstName: String!\n        nickName: String!\n        birthday: DateTime!\n        headThumb: String\n        desc: String\n        notified: Boolean\n        activated: Boolean\n        facebookId: String\n        googleId: String\n        updatedAt: DateTime\n        courseIds: String\n      }\n\n      &quot;&quot;&quot;\n      可更新使用者參數\n      &quot;&quot;&quot;\n      input UserUpdateInput {\n        lastName: String\n        firstName: String\n        nickName: String\n        headThumb: String\n        desc: String\n        notified: Boolean\n        activated: Boolean\n        facebookId: String\n        googleId: String\n      }\n\n      &quot;&quot;&quot;\n      使用者欄位\n      &quot;&quot;&quot;\n      type User {\n        id: ID\n        email: String\n        lastName: String\n        firstName: String\n        nickName: String\n        birthday: DateTime\n        headThumb: String\n        desc: String\n        notified: Boolean\n        activated: Boolean\n        facebookId: String\n        googleId: String\n        createdAt: DateTime\n        updatedAt: DateTime\n        courseIds: String\n      }\n\n      &quot;&quot;&quot;\n      篩選User參數\n      &quot;&quot;&quot;\n      input UserFilterKey {\n        email: TableStringFilterInput\n        lastName: TableStringFilterInput\n        firstName: TableStringFilterInput\n        nickName: TableStringFilterInput\n        gender: TableStringFilterInput\n      }\n\n      &quot;&quot;&quot;\n      排序User參數\n      &quot;&quot;&quot;\n      input UserOrderByInput {\n        email: Sort\n        firstName: Sort\n        birthday: Sort\n        createdAt: Sort\n        updatedAt: Sort\n      }\n\n      ##################### Root Object ###################\n\n      type Query {\n        currentUser: User\n        users(filter: UserFilterKey, skip: Int, take: Int, orderBy: UserOrderByInput): [User!]\n        signIn(email: String!, password: String!): User\n      }\n\n      type Mutation {\n        signUp(data: UserCreateInput!): User\n        updateUser(userId: Int!, data: UserUpdateInput!): User\n        deleteUser(userId: Int!): Boolean\n      }\n    `;\n\n    module.exports = {\n      typeDefs,\n    };\n    ```\n\n順便看一下在 playground 打 signUp 怎麼操作\n![](https://i.imgur.com/PCt8w0Y.png)</code>\n        </deckgo-highlight-code>\n</li>\n</ol>\n</li>\n</ul>\n<h3>3. resolvers</h3>\n<ul>\n<li>上次主要提到的，相當於 GraphQL query handler、controller 的概念，定義 GraphQL query response 的 functions 集合，這每個 function 都是 schema 的 type 或 field 的 resolver</li>\n<li>\n<p>看個範例</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">// resolvers.js\nconst path = require(&#39;path&#39;);\nconst { DateTimeResolver, DateResolver } = require(&#39;graphql-scalars&#39;);\nconst bcrypt = require(&#39;bcrypt&#39;);\nconst crypto = require(&#39;crypto&#39;);\nconst jwt = require(&#39;jsonwebtoken&#39;);\nconst { AuthenticationError, ForbiddenError, UserInputError } = require(&#39;apollo-server-core&#39;);\nconst { combineResolvers, skip } = require(&#39;graphql-resolvers&#39;);\n\nconst createTokens = (user) =&gt; {\nconst refreshToken = jwt.sign({ userId: user.id, count: user.count }, process.env.REFRESH_TOKEN_SECRET, {\n  expiresIn: &#39;7d&#39;,\n});\nconst accessToken = jwt.sign({ userId: user.id }, process.env.ACCESS_TOKEN_SECRET, {\n  expiresIn: &#39;15min&#39;,\n});\nreturn { refreshToken, accessToken };\n};\n\nconst isAuthenticated = async (parent, args, { prisma, currentUser, request }) =&gt; {\nif (currentUser) {\n  const user = await prisma.user.findOne({\n    where: {\n      id: Number(currentUser.userId),\n    },\n  });\n  if (user) {\n    return skip;\n  }\n}\nreturn new AuthenticationError(&#39;未認證無法存取，請先登入&#39;);\n};\n\nconst resolvers = {\nDateTime: DateTimeResolver,\nDate: DateResolver,\nQuery: {\n  currentUser: async (parent, args, { prisma, currentUser }) =&gt; {\n    if (!currentUser || !currentUser.userId) {\n      throw new AuthenticationError(&#39;當前未登入！請重新登錄&#39;);\n    }\n    return await prisma.user.findOne({ where: { id: currentUser.userId } });\n  },\n  users: combineResolvers(\n    isAuthenticated,\n    async (parent, { filter, skip, take, orderBy }, { prisma }) =&gt;\n      await prisma.user.findMany({ where: filter || {}, skip, take, orderBy })\n  ),\n  signIn: async (parent, { email, password }, { prisma, response, request }) =&gt; {\n    const user = await prisma.user.findOne({ where: { email } });\n    if (!user || !bcrypt.compareSync(password, user.password)) {\n      throw new AuthenticationError(&#39;登入失敗：帳號或密碼錯誤&#39;);\n    }\n    const { accessToken, refreshToken } = createTokens(user);\n    response.cookie(&#39;refreshToken&#39;, refreshToken, { httpOnly: true });\n    response.cookie(&#39;accessToken&#39;, accessToken, { httpOnly: true });\n    return user;\n  },\n},\nMutation: {\n  signUp: async (parent, { data }, { prisma }) =&gt; {\n    if (!!(await prisma.user.findOne({ where: { email: data.email } }))) {\n      throw new UserInputError(&#39;已註冊，請直接登入&#39;);\n    }\n    data.password = bcrypt.hashSync(data.password, 12);\n    return await prisma.user.create({\n      data,\n    });\n  },\n  updateUser: async (parent, { userId, data }, { prisma }) =&gt; {\n    return await prisma.user.update({\n      where: { id: userId },\n      data,\n    });\n  },\n  deleteUser: async (parent, { userId }, { prisma }, info) =&gt; {\n    await prisma.user.delete({ where: { id: userId } });\n    return true;\n  },\n},\n};\n\nmodule.exports = {\nresolvers,\n};</code>\n        </deckgo-highlight-code>\n</li>\n<li>之後想要做身份認證的話，可以使用 <code>graphql-resolvers</code>，用 combineResolvers 把多個 resolver 包起（應該是種 Higher order functions?）會由左至右順序執行(前面 resolver 要 return skip，最後一個仍要回傳 Schema 定義的回傳型別 data)</li>\n<li>Prisma Client 就是在 resolver 裡使用的操作資料管道（必須在前面定義好 Schema 下 <code>npx prisma generate</code> 才會更新得以正常使用）<a href=\"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/crud\" target=\"_blank\" rel=\"nofollow\">詳細 CRUD 說明請參閱 Prisma 官方文件</a></li>\n</ul>\n<h2>GraphQL Pagination Schema</h2>\n<blockquote>\n<p>Use Nodes when you have a finite list to use but don’t need the cursors for pagination. Use Edges when you have large list and you need to know the cursors to paginate</p>\n</blockquote>\n<ul>\n<li><a href=\"https://medium.com/javascript-in-plain-english/graphql-pagination-using-edges-vs-nodes-in-connections-f2ddb8edffa0\" target=\"_blank\" rel=\"nofollow\">GraphQL Pagination best practices: Using Edges vs Nodes in Connections</a></li>\n<li><a href=\"https://relay.dev/graphql/connections.htm\" target=\"_blank\" rel=\"nofollow\">GraphQL Cursor Connections Specification</a></li>\n<li><a href=\"https://medium.com/@smallbee/super-fast-offset-pagination-with-prisma2-21db93e5cc90\" target=\"_blank\" rel=\"nofollow\">https://medium.com/@smallbee/super-fast-offset-pagination-with-prisma2-21db93e5cc90</a></li>\n</ul>\n<h2>Resources</h2>\n<ul>\n<li><a href=\"https://graphql.org/learn/\" target=\"_blank\" rel=\"nofollow\">GraphQL</a> 🔆</li>\n<li><a href=\"https://ithelp.ithome.com.tw/users/20111997/ironman/1878\" target=\"_blank\" rel=\"nofollow\">2019 iT 邦幫忙鐵人賽 - Think in GraphQL 系列</a></li>\n<li><a href=\"https://blog.logrocket.com/code-first-vs-schema-first-development-graphql/\" target=\"_blank\" rel=\"nofollow\">Code-first vs. schema-first development in GraphQL</a></li>\n<li><a href=\"https://github.com/Shopify/graphql-design-tutorial/blob/master/TUTORIAL.md\" target=\"_blank\" rel=\"nofollow\">Shopify Tutorial: Designing a GraphQL API</a></li>\n<li>\n<p><a href=\"https://ithelp.ithome.com.tw/articles/10207606\" target=\"_blank\" rel=\"nofollow\">N+1 Problem → GraphQL Design: 使用 DataLoader 提升效能 !</a></p>\n<blockquote>\n<p><a href=\"https://github.com/Tyler-ntut/singple_backend\" target=\"_blank\" rel=\"nofollow\">Github singple_backend</a></p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h2>Workshop</h2>\n<p>Clone → <a href=\"https://gitlab.baifu-tech.net/f2e_tw/serverworkshop\" target=\"_blank\" rel=\"nofollow\">https://gitlab.baifu-tech.net/f2e_tw/serverworkshop</a></p>\n<ul>\n<li>Define prisma schema and create tables</li>\n<li>Define graphql schema, api entry point, and implement the resolvers</li>\n<li>Add <a href=\"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/filtering\" target=\"_blank\" rel=\"nofollow\">Filter</a> input type</li>\n<li>Add Sort input type</li>\n<li>Self Relation examples (self-relations branch)</li>\n<li>Spilt TypeDefs &#x26; Resolvers (spilt-files-example)</li>\n</ul>","timeToRead":9,"frontmatter":{"title":"Apollo Server 入門篇","date":"10 Sep 2020","tags":["apollo"],"path":"blog/20200910","excerpt":"快速複習去年分享的 GraphQL Schema 和 Client query 語法，並簡介如何以 Apollo Server 建立 GraphQL Server。"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"blog/20210725","title":"初試 SonarQube","tags":["tool"],"excerpt":"記錄下認識的新東西。"}}},{"node":{"frontmatter":{"path":"blog/20220206","title":"淺入淺出 Service Worker","tags":["javascript"],"excerpt":"簡單紀錄下關於 PWA 與 Service Worker 的觀點與主要功能。"}}},{"node":{"frontmatter":{"path":"blog/20210725-2","title":"SVGR 設置","tags":["javascript"],"excerpt":"webpack loader 以 Component 方式使用 Svg。"}}},{"node":{"frontmatter":{"path":"blog/20210110","title":"Pop Quiz","tags":["javascript"],"excerpt":"記錄踩到的陷阱題。"}}},{"node":{"frontmatter":{"path":"blog/20210109-3","title":"REST / RESTful & HTTP Methods","tags":["javascript"],"excerpt":"簡易整理。"}}},{"node":{"frontmatter":{"path":"blog/20210109","title":"Response Set-Cookie 無效","tags":["apollo"],"excerpt":"記錄個之前在和同事們弄 Side project 時犯蠢遇到的問題與解決方式。"}}},{"node":{"frontmatter":{"path":"blog/20210109-2","title":"IntersectionObserver","tags":["javascript"],"excerpt":"公司專案有個日期連動的 scroll 優化試驗，原先是監聽 scroll。"}}},{"node":{"frontmatter":{"path":"blog/20190909","title":"Prisma - Schema, Data Model, Relations, Client","tags":["prisma"],"excerpt":"未來 Side project 可能會應用到的 SDL first 開發流程角度，簡介此可以取代傳統 ORM 的 DB toolkit。"}}},{"node":{"frontmatter":{"path":"blog/20200630","title":"Express - Authentication, Authorization and Security","tags":["security","express"],"excerpt":"簡介 Express RESTful API Server 範例中 JWT 權限、授權相關。"}}},{"node":{"frontmatter":{"path":"blog/20200518","title":"常用 NoSQL 雲端資料庫 - Part 1 MongoDB","tags":["mongodb"],"excerpt":"簡介 Relational/NoSQL database、mongoose ORM 寫 mongo CRUD API。"}}},{"node":{"frontmatter":{"path":"blog/20200527","title":"常用 NoSQL 雲端資料庫 - Part 2 Firebase","tags":["firebase"],"excerpt":"簡介 Google 提供的後端服務平臺（BaaS）中的兩種 DB，realtime database 和 cloud firestore。"}}},{"node":{"frontmatter":{"path":"blog/20191107","title":"Javascript Event loop - macro task & micro task","tags":["javascript"],"excerpt":"介紹 Event loop 容易混淆的異步任務 macro task & micro task。"}}},{"node":{"frontmatter":{"path":"blog/20191125","title":"初探 RxJS（下）","tags":["rxjs"],"excerpt":"簡介上次未完的 RxJS 剩餘角色，和介紹目前公司後台專案使用的 redux-observable。"}}},{"node":{"frontmatter":{"path":"blog/20191017","title":"初探 RxJS（上）","tags":["rxjs"],"excerpt":"簡介相關的設計模式中的 Behavioral Pattern，再介紹 RxJS（先講 Observable）"}}},{"node":{"frontmatter":{"path":"blog/20190907","title":"GraphQL & Apollo Client","tags":["apollo"],"excerpt":"簡單介紹 React Client 端如何用 Apollo 對 GraphQL Server 做資料存取操作。"}}},{"node":{"frontmatter":{"path":"blog/20190906","title":"初探 Storybook","tags":["javascript"],"excerpt":"初探這款能夠在開發前端元件或是函式庫的同時，可以快速地建立元件各種操作模式或是樣式的工具。"}}},{"node":{"frontmatter":{"path":"blog/20190906-2","title":"React Hooks - useCallback, useMemo, useRef","tags":["reactjs"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20190707","title":"JavaScript HTML5 Web Worker & CRA 使用踩雷","tags":["javascript"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20180521","title":"Web 常見攻擊手法","tags":["security"],"excerpt":"擁有基本的資安觀念保護好自家資料和 user 使用環境是開發人員重要的一點。"}}},{"node":{"frontmatter":{"path":"blog/20180514","title":"JavaScript 中 this 指向","tags":["javascript"],"excerpt":"簡介 this 指向的六種情況。"}}},{"node":{"frontmatter":{"path":"blog/20190108","title":"JavaScript 認識非同步 Callback, Promise, async/await","tags":["javascript"],"excerpt":"Asynchronous 非同步的不同寫法的整理筆記。"}}},{"node":{"frontmatter":{"path":"blog/20170714","title":"WebForm 使用 reCAPTCHA 驗證","tags":["asp.net"],"excerpt":"這個我不是機器人驗證一定不陌生，滿多登入畫面會看到的，剛好今天接到把圖形驗證改為 reCAPTCHA 就順手記下。"}}},{"node":{"frontmatter":{"path":"blog/20170728","title":"WebForm 註冊 JavaScript","tags":["asp.net","javascript"],"excerpt":"動態產生JS在目前公司專案中是滿常用到的小技巧，不同的用法會產生在Web Page 的不同位置而有直譯式語言的前後順序差。"}}},{"node":{"frontmatter":{"path":"blog/20170604","title":"Web App 推播通知","tags":["asp.net"],"excerpt":"隨著行動和穿載裝置的興起，推播通知 (Push Notification) 成為維繫App用戶關係相當有力的工具"}}},{"node":{"frontmatter":{"path":"blog/20170508","title":"WebForm 圖片上傳檢查","tags":["asp.net"],"excerpt":"開放上傳有可能被傳奇怪東西的風險，只檢查所看到的副檔名，謹慎來說似乎是不夠的。"}}},{"node":{"frontmatter":{"path":"blog/20170421","title":"存取遠端 EventLog","tags":["asp.net","javascript"],"excerpt":"在公司中實作一個 Event log 的查詢工具。（之後來寫了 D3 呈現查詢異常查詢的部分）"}}}]}},"pageContext":{"postPath":"blog/20200910","translations":[{"hreflang":"en","path":"/blog/20200910"}]}},"staticQueryHashes":["4097791827"]}