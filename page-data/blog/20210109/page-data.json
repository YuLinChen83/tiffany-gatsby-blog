{"componentChunkName":"component---src-templates-post-post-jsx","path":"/blog/20210109","result":{"data":{"markdownRemark":{"html":"<p>在我們專案裡原本前後端都沒設定的情況下 request 是都可以發成功的（有 response 回來），但會發現 Server response 的 set cookie 沒有在 client 瀏覽器被設成功，但也沒有報錯誤警告（原本 GraphQL Playground 預設也不會 set，要開 setting 改成 <code>\"request.credentials\": \"include\"</code> 才如預期）\n<img src=\"https://i.imgur.com/uTZtYUO.png\">\n於是研究了一下</p>\n<h3><a href=\"https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS\" target=\"_blank\" rel=\"nofollow\">跨來源資源共用（CORS／Cross-Origin Resource Sharing）</a></h3>\n<div class=\"warning\">\n在（瀏覽器的）同源政策的規定下，如果是不同源的話，預設情況就會把回傳的 response 擋掉，不把結果傳回到 JavaScript（但注意是已經發到 Server 操作完畢了），以避免被竊取資料\n☞ 所以不透過瀏覽器是可以隨意發隨意得到結果的\n☞ 就算 Response 結果沒回來，此請求是有效的、已操作完的\n</div>\n<p>當我們在 JavaScript 中透過 fetch 或 XMLHttpRequest 存取資源時，需要遵守 CORS。瀏覽器在發送請求之前會先發送 <strong>preflight request (預檢請求)</strong>，確認伺服器端設定正確的 <code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code> 及 <code>Access-Control-Allow-Origin</code> 等 header，才會實際發送請求</p>\n<p>（結果一開始前後端什麼都沒設定也沒有遇到 CORS⋯⋯\n看到 Apollo Server 可以把 cors 關掉，總之先試再說\n<a href=\"https://www.apollographql.com/docs/apollo-server/api/apollo-server/\" target=\"_blank\" rel=\"nofollow\"><img src=\"https://i.imgur.com/IijK0wR.png\">\n</a></p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">const server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  formatError: (err) =&gt; ({ message: err.message }),\n  context,\n  cors: false,\n});</code>\n        </deckgo-highlight-code>\n<p>會得到結果\n<img src=\"https://i.imgur.com/v35Xfqy.png\">\n看一下 request header 少了一堆東西（原來不能隨便關\n<img src=\"https://i.imgur.com/KPmEsY9.png\">\n比對原本什麼都沒設的 request header\n<img src=\"https://i.imgur.com/OqAktH8.png\"></p>\n<p>後來在 set cookie 那試加 SameSite\n先來提一下：</p>\n<h4>CSRF／Cross Site Request Forgery／One-Click Attack／跨站請求偽造</h4>\n<blockquote>\n<p>因為瀏覽器的運行機制，只要發送 request 給某個網域，就會把關聯的 cookie 一起帶上去，如果使用者是登入狀態，發到與登入頁同網域的 request 中就會自動包含了他的資訊，就可以任意帶著身份發請求。</p>\n</blockquote>\n<ul>\n<li>看起來 CSRF 就是 Cookie 基於瀏覽器機制導致的安全性問題，但是 Chrome 51 版加入了功能：<a href=\"https://www.chromestatus.com/feature/4672634709082112\" target=\"_blank\" rel=\"nofollow\"><code>SameSite</code></a>，能在預設擋掉跨域請求的帶 Cookie 行為</li>\n</ul>\n<h4>SameSite</h4>\n<ul>\n<li>為一項在寫入 cookie (Set-Cookie: key=value) 時可加註的屬性 (attribute)</li>\n<li>\n<p>分為：</p>\n<ul>\n<li>Strict：僅限 same-site request 才能夠帶有此 cookie</li>\n<li>Lax：全部的 same-site request 以及部分 cross-site request 能夠寫入 cookie</li>\n<li>Chrome 80+ 後所有 Set-Cookie 未預設 SameSite 屬性的預設值</li>\n<li>\n<p>部分包含能送出 request 的網頁元件：</p>\n<ul>\n<li><code>&#x3C;a></code></li>\n<li><code>&#x3C;link rel=\"prerender\"></code></li>\n<li>\n<p><code>&#x3C;form method=\"GET\"></code></p>\n<div class=\"danger\">\nCross-site 登入機制緩衝調整：為了避免上線後大量使用第三方認證與登入機制的網站失效，目前初步上線的行為為 “Lax + POST” 模式。意味著如果是透過跨網域 (cross-site) 登入且使用 POST 發送請求的機制時，未被標示任何 SameSite 屬性的 Cookie 將允許被掛在請求上發送，但時限為兩分鐘。這項機制未來有機會被移除。\n</div>\n</li>\n</ul>\n</li>\n<li>\n<p>若需發送第三方 cookie，需加上 <code>SameSite=None; Secure</code> 才會生效</p>\n<ul>\n<li>Secure 指定需透過 Https 發 request</li>\n</ul>\n</li>\n<li>None：無論是 same-site 還是 cross-site 的 request 上， 都可以帶有該 cookie</li>\n<li>Chrome 舊版預設</li>\n</ul>\n</li>\n<li>如何應應？針對會成為第三方用途的 cookie 掛上 <code>SameSite=None; Secure</code>；而針對只有在自己 domain 下會使用到的 Cookie 加上 <code>SameSite=Strict</code> 或 <code>SameSite=Lax</code></li>\n<li><a href=\"https://samesite-sandbox.glitch.me/\" target=\"_blank\" rel=\"nofollow\">這邊可以看當前瀏覽器 SameSite 版本規則</a>，全部為綠色則為已開啟</li>\n<li>\n<p>還是得實作 CSRF Token</p>\n<blockquote>\n<p>話說前面根本都試錯方向囧</p>\n</blockquote>\n</li>\n</ul>\n<h3>最後解決：再看一次文檔 <a href=\"https://www.apollographql.com/docs/react/networking/authentication/#cookie\" target=\"_blank\" rel=\"nofollow\">Apollo Authentication Cookie</a> 照著加設定</h3>\n<blockquote>\n<p>You just need to pass the credentials option. e.g. <code>credentials: 'same-origin'</code> as shown below, if your backend server is the same domain or else <code>credentials: 'include'</code> if your backend is a different domain.</p>\n</blockquote>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">// Client\nconst link = createUploadLink({\n  uri: &#39;http://localhost:4403&#39;,\n  credentials: &#39;include&#39;, // local前後端不同port算跨域所以include\n});\n\nconst client = new ApolloClient({\n  connectToDevTools: true,\n  cache,\n  link,\n});</code>\n        </deckgo-highlight-code>\n<p>只加了 Client 的 credentials: 'include' 設定：\n<img src=\"https://i.imgur.com/kq8PFI4.png\">\n因為漏掉 Server 也要加設定</p>\n<blockquote>\n<p>Note: the backend must also allow credentials from the requested origin. e.g. if using the popular 'cors' package from npm in node.js, the following settings would work in tandem with the above apollo client settings:\n使用 cookie 的情況下還需額外設定 <code>Access-Control-Allow-Credentials</code> header。</p>\n</blockquote>\n<p>加了 credentials: true：\n<img src=\"https://i.imgur.com/iGKkStj.png\">\n因為還要設定 origin</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">// Server\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  formatError: (err) =&gt; ({ message: err.message }),\n  context,\n  cors: {\n    origin: &#39;http://localhost:9000&#39;,\n    credentials: true,\n  },\n});</code>\n        </deckgo-highlight-code>\n<p>兩邊都設對再試 Cookie 就能設成功了\n可以參考 <a href=\"https://medium.com/d-d-mag/%E5%92%8C-cors-%E8%B7%9F-cookie-%E6%89%93%E4%BA%A4%E9%81%93-dd420ccc7399\" target=\"_blank\" rel=\"nofollow\">和 CORS 跟 cookie 打交道</a> 大概理解</p>\n<blockquote>\n<p>cookie 並不能跨域傳遞，也就是說不同 origin 中的 cookie 沒辦法互相傳遞及存取。不過如果你在 a 網域送出了 b 網域的請求，且 b 網域回傳了 cookie 的訊息，那麼在 a 網域會以 b 網域的形式儲存一份 cookie，如果沒有設定 <code>withCredentials</code> 或是 <code>credentials: ‘include’</code> 的話，就算伺服器有回傳 Set-Cookie，一樣不會被寫入。</p>\n<p>在一般情況下如果再使用 b 網域的 API，cookie 是不會自動被送出去的。這個情況下，你必須在 XHR 設定 withCredentials 或是 fetch 的選項中設置 <code>{ credentials: 'include' }</code>，因為這也是一個跨域請求，所以也必須遵照 CORS 要件加入 <code>Access-Control-Allow-Origin</code> (Server)</p>\n<p>此外瀏覽器會自動拒絕沒有 <code>Access-Control-Allow-Credentials</code> 的回應，也因此如果要能夠將身份訊息傳到跨網域的伺服器當中，必須額外加上 <code>Access-Control-Allow-Credentials: true</code></p>\n</blockquote>\n<h4>包含憑證(Credentials) 的 Request 用法（設在 Apollo Client link）</h4>\n<ul>\n<li><code>include</code>：讓瀏覽器將 credentials 跟著 request 一起送出</li>\n<li><code>same-origin</code>：讓瀏覽器將 credentials 只發送給同源的 URL</li>\n<li><code>omit</code>：確保瀏覽器不會帶著 credentials 請求</li>\n</ul>\n<h4>簡單跨網域請求</h4>\n<p>如果資源應該要限制請求者的網域（domain），或是假如資源需要身分驗證（credentials）來進行存取（或是要設定驗證）。則篩選請求的 Origin 標頭就可能是必要的，或至少呼應請求者的 Origin 標頭值（例如 Access-Control-Allow-Origin: <a href=\"http://localhost:9000%EF%BC%89%E3%80%82%E5%8F%A6%E5%A4%96%EF%BC%8C%E5%B0%87%E6%9C%83%E7%99%BC%E9%80%81\" target=\"_blank\" rel=\"nofollow\">http://localhost:9000）。另外，將會發送</a> Access-Control-Allow-Credentials: true 標頭</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://blog.techbridge.cc/2017/02/25/csrf-introduction/\" target=\"_blank\" rel=\"nofollow\">讓我們來談談 CSRF</a></li>\n<li><a href=\"https://medium.com/@azure820529/chrome-80-%E5%BE%8C%E9%87%9D%E5%B0%8D%E7%AC%AC%E4%B8%89%E6%96%B9-cookie-%E7%9A%84%E8%A6%8F%E5%89%87%E8%AA%BF%E6%95%B4-default-samesite-lax-aaba0bc785a3\" target=\"_blank\" rel=\"nofollow\">Chrome 80 後針對第三方 Cookie 的規則調整 (default SameSite=Lax)</a></li>\n<li><a href=\"https://blog.kalan.dev/2020-04-13-chrome-cookie-%E6%94%BF%E7%AD%96%E8%AA%BF%E6%95%B4%E8%88%87%E5%8F%8D%E6%80%9D/\" target=\"_blank\" rel=\"nofollow\">Chrome Cookie 政策調整與反思</a></li>\n<li><a href=\"https://blog.kalan.dev/2020-10-18-rethink-cookie-and-cors/\" target=\"_blank\" rel=\"nofollow\">關於 Cookie 與 CORS 的再思考</a></li>\n<li><a href=\"https://medium.com/d-d-mag/%E5%92%8C-cors-%E8%B7%9F-cookie-%E6%89%93%E4%BA%A4%E9%81%93-dd420ccc7399\" target=\"_blank\" rel=\"nofollow\">和 CORS 跟 cookie 打交道</a></li>\n<li><a href=\"https://medium.com/@des75421/cors-%E8%B7%A8%E4%BE%86%E6%BA%90%E8%B3%87%E6%BA%90%E5%85%B1%E7%94%A8cors-191d4bfc4735\" target=\"_blank\" rel=\"nofollow\">【CORS】跨來源資源共用 CORS</a></li>\n</ul>","timeToRead":6,"frontmatter":{"title":"Response Set-Cookie 無效","date":"09 Jan 2021","tags":["apollo"],"path":"blog/20210109","excerpt":"記錄個之前在和同事們弄 Side project 時犯蠢遇到的問題與解決方式。"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"blog/20210725-2","title":"SVGR 設置","tags":["javascript"],"excerpt":"webpack loader 以 Component 方式使用 Svg。"}}},{"node":{"frontmatter":{"path":"blog/20210725","title":"初試 SonarQube","tags":["tool"],"excerpt":"記錄下認識的新東西。"}}},{"node":{"frontmatter":{"path":"blog/20210110","title":"Pop Quiz","tags":["javascript"],"excerpt":"記錄踩到的陷阱題。"}}},{"node":{"frontmatter":{"path":"blog/20210109-2","title":"IntersectionObserver","tags":["javascript"],"excerpt":"公司專案有個日期連動的 scroll 優化試驗，原先是監聽 scroll。"}}},{"node":{"frontmatter":{"path":"blog/20200910","title":"Apollo Server 入門篇","tags":["apollo"],"excerpt":"快速複習去年分享的 GraphQL Schema 和 Client query 語法，並簡介如何以 Apollo Server 建立 GraphQL Server。"}}},{"node":{"frontmatter":{"path":"blog/20190909","title":"Prisma - Schema, Data Model, Relations, Client","tags":["prisma"],"excerpt":"未來 Side project 可能會應用到的 SDL first 開發流程角度，簡介此可以取代傳統 ORM 的 DB toolkit。"}}},{"node":{"frontmatter":{"path":"blog/20210109-3","title":"REST / RESTful & HTTP Methods","tags":["javascript"],"excerpt":"簡易整理。"}}},{"node":{"frontmatter":{"path":"blog/20200527","title":"常用 NoSQL 雲端資料庫 - Part 2 Firebase","tags":["firebase"],"excerpt":"簡介 Google 提供的後端服務平臺（BaaS）中的兩種 DB，realtime database 和 cloud firestore。"}}},{"node":{"frontmatter":{"path":"blog/20200630","title":"Express - Authentication, Authorization and Security","tags":["security","express"],"excerpt":"簡介 Express RESTful API Server 範例中 JWT 權限、授權相關。"}}},{"node":{"frontmatter":{"path":"blog/20200518","title":"常用 NoSQL 雲端資料庫 - Part 1 MongoDB","tags":["mongodb"],"excerpt":"簡介 Relational/NoSQL database、mongoose ORM 寫 mongo CRUD API。"}}},{"node":{"frontmatter":{"path":"blog/20191125","title":"初探 RxJS（下）","tags":["rxjs"],"excerpt":"簡介上次未完的 RxJS 剩餘角色，和介紹目前公司後台專案使用的 redux-observable。"}}},{"node":{"frontmatter":{"path":"blog/20191107","title":"Javascript Event loop - macro task & micro task","tags":["javascript"],"excerpt":"介紹 Event loop 容易混淆的異步任務 macro task & micro task。"}}},{"node":{"frontmatter":{"path":"blog/20190907","title":"GraphQL & Apollo Client","tags":["apollo"],"excerpt":"簡單介紹 React Client 端如何用 Apollo 對 GraphQL Server 做資料存取操作。"}}},{"node":{"frontmatter":{"path":"blog/20191017","title":"初探 RxJS（上）","tags":["rxjs"],"excerpt":"簡介相關的設計模式中的 Behavioral Pattern，再介紹 RxJS（先講 Observable）"}}},{"node":{"frontmatter":{"path":"blog/20190906","title":"初探 Storybook","tags":["javascript"],"excerpt":"初探這款能夠在開發前端元件或是函式庫的同時，可以快速地建立元件各種操作模式或是樣式的工具。"}}},{"node":{"frontmatter":{"path":"blog/20190707","title":"JavaScript HTML5 Web Worker & CRA 使用踩雷","tags":["javascript"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20190906-2","title":"React Hooks - useCallback, useMemo, useRef","tags":["reactjs"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20190108","title":"JavaScript 認識非同步 Callback, Promise, async/await","tags":["javascript"],"excerpt":"Asynchronous 非同步的不同寫法的整理筆記。"}}},{"node":{"frontmatter":{"path":"blog/20180521","title":"Web 常見攻擊手法","tags":["security"],"excerpt":"擁有基本的資安觀念保護好自家資料和 user 使用環境是開發人員重要的一點。"}}},{"node":{"frontmatter":{"path":"blog/20180514","title":"JavaScript 中 this 指向","tags":["javascript"],"excerpt":"簡介 this 指向的六種情況。"}}},{"node":{"frontmatter":{"path":"blog/20170714","title":"WebForm 使用 reCAPTCHA 驗證","tags":["asp.net"],"excerpt":"這個我不是機器人驗證一定不陌生，滿多登入畫面會看到的，剛好今天接到把圖形驗證改為 reCAPTCHA 就順手記下。"}}},{"node":{"frontmatter":{"path":"blog/20170508","title":"WebForm 圖片上傳檢查","tags":["asp.net"],"excerpt":"開放上傳有可能被傳奇怪東西的風險，只檢查所看到的副檔名，謹慎來說似乎是不夠的。"}}},{"node":{"frontmatter":{"path":"blog/20170604","title":"Web App 推播通知","tags":["asp.net"],"excerpt":"隨著行動和穿載裝置的興起，推播通知 (Push Notification) 成為維繫App用戶關係相當有力的工具"}}},{"node":{"frontmatter":{"path":"blog/20170728","title":"WebForm 註冊 JavaScript","tags":["asp.net","javascript"],"excerpt":"動態產生JS在目前公司專案中是滿常用到的小技巧，不同的用法會產生在Web Page 的不同位置而有直譯式語言的前後順序差。"}}},{"node":{"frontmatter":{"path":"blog/20170421","title":"存取遠端 EventLog","tags":["asp.net","javascript"],"excerpt":"在公司中實作一個 Event log 的查詢工具。（之後來寫了 D3 呈現查詢異常查詢的部分）"}}}]}},"pageContext":{"postPath":"blog/20210109","translations":[{"hreflang":"en","path":"/blog/20210109"}]}},"staticQueryHashes":["4097791827"]}