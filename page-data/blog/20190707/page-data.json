{"componentChunkName":"component---src-templates-post-post-jsx","path":"/blog/20190707","result":{"data":{"markdownRemark":{"html":"<p>JavaScript 是單執行緒、單線程（single threaded runtime）的程式語言，所有的程式碼片段都會在堆疊（主執行緒/Stack）中被執行，而且一次只會執行一個程式碼片段。Web worker 相當於可讓主線程開其他 thread。</p>\n<p>W3C：A web worker is a JavaScript running in the background, without affecting the performance of the page.\n這邊可以先看個簡介 <a href=\"https://www.fullstackreact.com/articles/introduction-to-web-workers-with-react/\" target=\"_blank\" rel=\"nofollow\">A Guide to using Web Workers in React</a><br>\n和這個 <a href=\"https://codesandbox.io/s/w2v7zzn63w\" target=\"_blank\" rel=\"nofollow\">codesandbox example</a> 感受一下有無使用 web worker 的 UI 體驗差別</p>\n<p>可以應用在輪詢、處理大量計算的情境。</p>\n<p>通訊使用先記得：不管主線程還是 woker 內，都是 <code>postMessage</code> 推、 <code>onmessage</code> 收。</p>\n<h3>Worker Example</h3>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">self.addEventListener(&#39;message&#39;, (event) =&gt; {\n  // 主線程推送觸發\n  self.postMessage(event.data); // 推送給主線程\n  self.close(); // worker 關閉自身釋放資源\n});</code>\n        </deckgo-highlight-code>\n<ol>\n<li>獨立的 js 檔案</li>\n<li>有著定義監聽 message 的事件（主線程 <code>postMessage</code> 時觸發）</li>\n<li>在 Worker 執行緒中， <code>self</code> 和 <code>this</code> 都代表子執行緒的全域性物件</li>\n<li><code>onmessage</code> 用法同 <code>addEventLister(‘message’, …)</code></li>\n<li><code>self.close()</code> 關閉 worker 自身</li>\n</ol>\n<h3>主線程 Example</h3>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">// main.js\nvar worker = new Worker(&#39;worker.js&#39;);\n// 主線程推 data 給 worker\nworker.postMessage(&#39;Hello World&#39;);\n\n// 主線程接收 worker 推過來的 data\nworker.onmessage = function(event) {\n  console.log(&#39;Received message &#39; + event.data);\n};\n// 等同於\nworker.addEventListener(&#39;message&#39;, function(event) {\n  // ...\n});\n\n// worker 內若有錯誤主線程 onerror 會監聽到\nworker.onerror = function(event) {\n  // ...\n};\n// 等同於\nworker.addEventListener(&#39;error&#39;, function(event) {\n  // ...\n});\n\n// 主線程釋放 worker\nworker.terminate();</code>\n        </deckgo-highlight-code>\n<ol>\n<li>創建 worker 實例</li>\n<li>定義推送、接收行為</li>\n<li>使用完要關閉以節省系統資源</li>\n</ol>\n<h2>Worker 內的限制</h2>\n<ol>\n<li>同源限制：同 domain</li>\n<li>DOM 限制（全局對象不同）：無法使用 <code>document</code> 、 <code>window</code> 、 <code>parent</code> 這些對象；但是 Worker 可以使用 <code>navigator</code> 和 <code>location</code> 對象。</li>\n<li>通信聯繫（ <code>postMessage</code> 、 <code>onmessage</code> ）</li>\n<li>腳本限制：不能使用 <code>alert()</code> 和 <code>confirm()</code> ；可以使用 XMLHttpRequest 做 AJAX 請求。</li>\n<li>本機文件限制：無法讀取本地文件，引用腳本需自網路</li>\n</ol>\n<h2>Worker 種類</h2>\n<ol>\n<li>專用線程（Dedicated Worker）：只能一個頁面使用</li>\n<li>共享線程（Shared Worker）：多個頁面共享使用</li>\n</ol>\n<h2>Create-React-App 使用 web worker</h2>\n<ul>\n<li><code>npm install react-worker</code></li>\n<li>worker 內要使用 ES6 寫法需要 <code>npm install worker-loader</code></li>\n<li>CRA 不 eject 的方法 react-app-rewired\n修改 config-overrides.js</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const filterWarning = (config) =&gt; {\n  ...\n  config.module.rules.push({\n    test: /\\.worker\\.js$/,\n    use: {loader: &#39;worker-loader&#39;},\n  });\n  config.output.globalObject = &#39;this&#39;;\n  return config;\n};</code>\n        </deckgo-highlight-code>\n<h3>註：</h3>\n<ol>\n<li>沒有 config.output.globalObject = 'this' 的話會抓不到 window</li>\n<li>worker 檔名要 .worker.js 結尾</li>\n</ol>\n<p>這次由於工作上有優化下載報表的需求而接觸了 web worker 並嘗試使用，稍作研究並整理了一點筆記紀錄。若有認知錯誤或描述不妥的地方歡迎指正並給予建議 😀<br>\n久違的更新筆記呢 其他躺在 hackmd 的雜亂筆記就 ⋯⋯（遠望  </p>\n<div class=\"gatsby-resp-iframe-wrapper\" style=\"padding-bottom: 58.333333333333336%; position: relative; height: 0; overflow: hidden; \" > <iframe src=\"https://docs.google.com/presentation/d/e/2PACX-1vR1LTgeM1uxiFadrOJSG9VwQOF_C4FbnINaLiap4UyL1YXDD5xcZ1MPwfrmKPWfpn4FEWRlU1ZGnUYX/embed\" style=\" position: absolute; top: 0; left: 0; width: 100%; height: 100%; \"></iframe> </div>","timeToRead":2,"frontmatter":{"title":"JavaScript HTML5 Web Worker & CRA 使用踩雷","date":"07 Jul 2019","tags":["javascript"],"path":"blog/20190707","excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"blog/20210109-3","title":"REST / RESTful & HTTP Methods","tags":["javascript"],"excerpt":"簡易整理。"}}},{"node":{"frontmatter":{"path":"blog/20210109-2","title":"IntersectionObserver","tags":["javascript"],"excerpt":"公司專案有個日期連動的 scroll 優化試驗，原先是監聽 scroll。"}}},{"node":{"frontmatter":{"path":"blog/20210110","title":"Pop Quiz","tags":["javascript"],"excerpt":"記錄踩到的陷阱題。"}}},{"node":{"frontmatter":{"path":"blog/20191107","title":"Javascript Event loop - macro task & micro task","tags":["javascript"],"excerpt":"介紹 Event loop 容易混淆的異步任務 macro task & micro task。"}}},{"node":{"frontmatter":{"path":"blog/20190108","title":"JavaScript 認識非同步 Callback, Promise, async/await","tags":["javascript"],"excerpt":"Asynchronous 非同步的不同寫法的整理筆記。"}}},{"node":{"frontmatter":{"path":"blog/20180521","title":"Web 常見攻擊手法","tags":["security"],"excerpt":"擁有基本的資安觀念保護好自家資料和 user 使用環境是開發人員重要的一點。"}}},{"node":{"frontmatter":{"path":"blog/20180514","title":"JavaScript 中 this 指向","tags":["javascript"],"excerpt":"簡介 this 指向的六種情況。"}}},{"node":{"frontmatter":{"path":"blog/20190906","title":"初探 Storybook","tags":["javascript"],"excerpt":"初探這款能夠在開發前端元件或是函式庫的同時，可以快速地建立元件各種操作模式或是樣式的工具。"}}},{"node":{"frontmatter":{"path":"blog/20170728","title":"WebForm 註冊 JavaScript","tags":["asp.net","javascript"],"excerpt":"動態產生JS在目前公司專案中是滿常用到的小技巧，不同的用法會產生在Web Page 的不同位置而有直譯式語言的前後順序差。"}}},{"node":{"frontmatter":{"path":"blog/20170604","title":"Web App 推播通知","tags":["asp.net"],"excerpt":"隨著行動和穿載裝置的興起，推播通知 (Push Notification) 成為維繫App用戶關係相當有力的工具"}}},{"node":{"frontmatter":{"path":"blog/20170714","title":"WebForm 使用 reCAPTCHA 驗證","tags":["asp.net"],"excerpt":"這個我不是機器人驗證一定不陌生，滿多登入畫面會看到的，剛好今天接到把圖形驗證改為 reCAPTCHA 就順手記下。"}}},{"node":{"frontmatter":{"path":"blog/20170508","title":"WebForm 圖片上傳檢查","tags":["asp.net"],"excerpt":"開放上傳有可能被傳奇怪東西的風險，只檢查所看到的副檔名，謹慎來說似乎是不夠的。"}}},{"node":{"frontmatter":{"path":"blog/20170421","title":"存取遠端 EventLog","tags":["asp.net","javascript"],"excerpt":"在公司中實作一個 Event log 的查詢工具。（之後來寫了 D3 呈現查詢異常查詢的部分）"}}},{"node":{"frontmatter":{"path":"blog/20210109","title":"Response Set-Cookie 無效","tags":["apollo"],"excerpt":"記錄個之前在和同事們弄 Side project 時犯蠢遇到的問題與解決方式。"}}},{"node":{"frontmatter":{"path":"blog/20200518","title":"常用 NoSQL 雲端資料庫 - Part 1 MongoDB","tags":["mongodb"],"excerpt":"簡介 Relational/NoSQL database、mongoose ORM 寫 mongo CRUD API。"}}},{"node":{"frontmatter":{"path":"blog/20191125","title":"初探 RxJS（下）","tags":["rxjs"],"excerpt":"簡介上次未完的 RxJS 剩餘角色，和介紹目前公司後台專案使用的 redux-observable。"}}},{"node":{"frontmatter":{"path":"blog/20190907","title":"GraphQL & Apollo Client","tags":["apollo"],"excerpt":"簡單介紹 React Client 端如何用 Apollo 對 GraphQL Server 做資料存取操作。"}}},{"node":{"frontmatter":{"path":"blog/20190906-2","title":"React Hooks - useCallback, useMemo, useRef","tags":["reactjs"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20200910","title":"Apollo Server 入門篇","tags":["apollo"],"excerpt":"快速複習去年分享的 GraphQL Schema 和 Client query 語法，並簡介如何以 Apollo Server 建立 GraphQL Server。"}}},{"node":{"frontmatter":{"path":"blog/20200527","title":"常用 NoSQL 雲端資料庫 - Part 2 Firebase","tags":["firebase"],"excerpt":"簡介 Google 提供的後端服務平臺（BaaS）中的兩種 DB，realtime database 和 cloud firestore。"}}},{"node":{"frontmatter":{"path":"blog/20200630","title":"Express - Authentication, Authorization and Security","tags":["security","express"],"excerpt":"簡介 Express RESTful API Server 範例中 JWT 權限、授權相關。"}}},{"node":{"frontmatter":{"path":"blog/20191017","title":"初探 RxJS（上）","tags":["rxjs"],"excerpt":"簡介相關的設計模式中的 Behavioral Pattern，再介紹 RxJS（先講 Observable）"}}},{"node":{"frontmatter":{"path":"blog/20190909","title":"Prisma - Schema, Data Model, Relations, Client","tags":["prisma"],"excerpt":"未來 Side project 可能會應用到的 SDL first 開發流程角度，簡介此可以取代傳統 ORM 的 DB toolkit。"}}}]}},"pageContext":{"postPath":"blog/20190707","translations":[{"hreflang":"en","path":"/blog/20190707"}]}}}