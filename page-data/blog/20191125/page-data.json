{"componentChunkName":"component---src-templates-post-post-jsx","path":"/blog/20191125","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://hackmd.io/fa3lKD0ZTPSuxuD-HbigBQ?view\" target=\"_blank\" rel=\"nofollow\">Hackmd</a></p>\n<ul>\n<li>上回分享 - <a href=\"https://hackmd.io/nG5GoMzKQWiIKc8l00dOjQ?both\" target=\"_blank\" rel=\"nofollow\">初探 RxJS（上）HackMD</a></li>\n<li><a href=\"https://rxjs-dev.firebaseapp.com/api\" target=\"_blank\" rel=\"nofollow\">RxJS API 文件</a> - 可搭配<a href=\"https://rxjs-cn.github.io/learn-rxjs-operators/\" target=\"_blank\" rel=\"nofollow\">學習 RxJS 操作符</a>，另外也推直接看 <a href=\"https://kknews.cc/zh-tw/other/yzzqgvg.html\" target=\"_blank\" rel=\"nofollow\">RxJS 快速入門</a>了解常用的 Operators</li>\n<li><a href=\"https://rxjs.dev/operator-decision-tree\" target=\"_blank\" rel=\"nofollow\">Operator Decision Tree</a> - 用選擇題尋找適合需求的 Operator</li>\n<li><a href=\"https://rxmarbles.com/\" target=\"_blank\" rel=\"nofollow\">RxJS Marbles</a> - 看具體化的異步事件<br><br></li>\n</ul>\n<p>還記得 RxJS 擁有的角色嗎？</p>\n<ul>\n<li>Observable 可觀察對象</li>\n<li>Observer 觀察者</li>\n<li>Subscription 訂閱</li>\n<li>Operators 操作符</li>\n<li>Subject 主體</li>\n<li>Schedulers 調度器<br><br></li>\n</ul>\n<blockquote>\n<p>上次簡單介紹了前三個，回憶一下：</p>\n<ul>\n<li>Observable = stream/資料流/流 = 多了時間維度的陣列，一連串資料事件為其元素</li>\n<li>當可被觀察的東西（Observable）有事情發生，觀察者（Observer）就可以做出反應</li>\n<li>Observable 被 subscribe 時才執行 → 訂閱一個 Observable 就像是執行一個 function</li>\n<li>調用 Observable 時返回的 Subscription 訂閱對象有 <code>unsubscribe()</code> 方法可以清理由 Subscription 所佔用的資源</li>\n<li>RxJS 的根基是 Observable，最有用的是它的操作符（Operator），允許複雜的異步程式以聲明式的方式輕鬆組合的基礎單元\nOperator 是無副作用的純函數，它基於當前的 Observable 創建一個新的 Observable，輸入 Observable（創建操作符不一定）、輸出 Observable（必定）</li>\n</ul>\n</blockquote>\n<h3>Pipeable</h3>\n<p>先更新上次 LINQ 風格的鍊型寫法，我們捨棄 Observable.operator(...).operator(...)... 的寫法，改為 RxJS 5.5 後建議的 Pipeable 寫法</p>\n<ul>\n<li>\n<p>Why?</p>\n<ul>\n<li>patching prototype 造成很多問題</li>\n<li>global</li>\n<li>\n<p>not tree-shakeable</p>\n<ul>\n<li>無法像 webpack 移除 JavaScript 上下文中的未引用代码(dead-code)</li>\n</ul>\n</li>\n<li>創建自定義操作符也變得簡單</li>\n<li>Compilers 和 linters 提供更多幫助</li>\n</ul>\n</li>\n</ul>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">// an operator chain, RxJS 舊的鍊型寫法\nsource\n  .map((x) =&gt; x + x)\n  .mergeMap((n) =&gt;\n    of(n + 1, n + 2)\n      .filter((x) =&gt; x % 1 == 0)\n      .scan((acc, x) =&gt; acc + x, 0)\n  )\n  .catch((err) =&gt; of(&#39;error found&#39;))\n  .subscribe(printResult);\n\n// 改 pipe flow, 用 pipe 包操作符\nsource\n  .pipe(\n    map((x) =&gt; x + x),\n    mergeMap((n) =&gt;\n      of(n + 1, n + 2).pipe(\n        filter((x) =&gt; x % 1 == 0),\n        scan((acc, x) =&gt; acc + x, 0)\n      )\n    ),\n    catchError((err) =&gt; of(&#39;error found&#39;))\n  )\n  .subscribe(printResult);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>\n<p>注意</p>\n<ul>\n<li>此改動有些為了不能和 JavaScript 的關鍵字衝突，所以名稱有部分變動</li>\n<li>如果是 5 升 6 可以添加 <code>rxjs-compat</code> package 使能保持 v5 代碼運行的同時逐漸遷移</li>\n<li>盡量直接導入所需的 Observable 創建操作符創建 Observable</li>\n</ul>\n</li>\n</ul>\n<h4>自定義 Operator</h4>\n<blockquote>\n<p>Operator 是返回 Observable 的<strong>純函數</strong></p>\n</blockquote>\n<ul>\n<li>\n<p>基本上</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">const customOperator = &lt;T&gt;() =&gt; (source: Observable&lt;T&gt;) =&gt; new Observable&lt;T&gt;((subscriber) =&gt; {\n  return source.subscribe({\n    next(value) { subscriber.next(value); },\n    error(err) { subscriber.error(err); },\n    complete() { subscriber.complete(); },\n });\n});\n});\n\nsource$.pipe(\ncustomOperator(),\n)</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>範例：創建一個接受計算 callback function 的 calculate operator</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">const calculate = (fn) =&gt; (source) =&gt;\nsource.pipe(\n  map((value) =&gt; fn(value)),\n  catchError((err) =&gt; of(err))\n);\n\nof(5, 2, &#39;hello&#39;)\n.pipe(calculate((value) =&gt; Math.pow(value, 2)))\n.subscribe(console.log);</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>想想看：創建一個 toUpperCase Operator</p>\n<ul>\n<li>須考慮若接收不是字串會 error</li>\n<li>用到的 Operator ?</li>\n<li><a href=\"https://codesandbox.io/s/rxjs-painting-example-3msgj?fontsize=14\" target=\"_blank\" rel=\"nofollow\">CodeSandBox</a></li>\n</ul>\n</li>\n<li>\n<p>自定義 Operator 需注意：\n若返回值依賴於在自定義運算符中存儲的狀態會遇問題，最好避免，舉例：</p>\n<ol>\n<li>Operator 行為不同</li>\n</ol>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">import { pipe, range } from &#39;rxjs&#39;;\nimport { map, tap, share } from &#39;rxjs/operators&#39;;\n\nconst custom = () =&gt; {\n  let state = 0;\n  return pipe(\n    map((next) =&gt; state * next),\n    tap((_) =&gt; (state += 1)),\n    share()\n  );\n};\n\nconst op = custom();\nconsole.log(&#39;first use:&#39;);\nrange(1, 2)\n  .pipe(op)\n  .subscribe((n) =&gt; console.log(n));\nconsole.log(&#39;second use:&#39;);\nrange(1, 2)\n  .pipe(op)\n  .subscribe((n) =&gt; console.log(n));</code>\n        </deckgo-highlight-code>\n<ul>\n<li><a href=\"https://rxjs-cn.github.io/learn-rxjs-operators/operators/multicasting/share.html\" target=\"_blank\" rel=\"nofollow\"><code>share()</code></a> 使能在多個訂閱者間共享 observable\n共享的話多次被訂閱只會執行一次 side effect\nshare 就像是使用了 Subject 和 refCount 的 multicast（後面介紹）</li>\n<li>不同的訂閱將在其下一個通知中接收不同的值（操作符內的狀態是共享的）</li>\n</ul>\n</li>\n</ul>\n<h3>來寫寫看吧ヽ(✿ ﾟ ▽ ﾟ)ノ</h3>\n<ol>\n<li>\n<p>在 canvas 上畫畫</p>\n<ul>\n<li><a href=\"https://codesandbox.io/s/rxjs-playground-ok7mz?fontsize=14\" target=\"_blank\" rel=\"nofollow\">CodeSandBox</a></li>\n<li>\n<p>現有環境下 在 <code>index.js</code>\n以 mousemove 行為創建 observable 出發，用提示的 <code>skipUntil, takeUntil</code> Operators 來組合看看</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">const paints$ = move$\n.pipe\n// 以 mousemove 行為創建 observable 作為出發寫寫看\n();</code>\n        </deckgo-highlight-code>\n<p>加上 <code>repeat</code>（缺點</p>\n</li>\n<li>\n<p>以 mousedown 行為創建 observable 出發，用提示的 <code>takeUntil, mergeMap</code> Operators 來組合看看\n<code>javascript= const paints$ = down$.pipe( // 以 mousedown 行為創建 observable 作為出發寫寫看 );</code></p>\n<blockquote>\n<p>RxJS has so many ways to get the same answer</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<h4>Subject</h4>\n<p>允許將值<strong>多播</strong>給多個觀察者，將任意 Observable 執行共享給多個觀察者的唯一方式</p>\n<ul>\n<li>\n<p>與 Observable 的不同：</p>\n<ul>\n<li>普通的 Observables 是單播的，每個已訂閱的觀察者都擁有 Observable 的獨立執行</li>\n<li>在 Subject subscribe 不會調用發送值的新執行，而是將給定的觀察者註冊到觀察者列表中，像 addListener 那樣</li>\n</ul>\n</li>\n<li>\n<p>是一個 Observer，同時也是一個 Observable</p>\n<ul>\n<li>Observable：Subject 可以被訂閱</li>\n</ul>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">var subject = new Rx.Subject();\n\nsubject.subscribe({\nnext: (v) =&gt; console.log(&#39;observerA: &#39; + v),\n});\nsubject.subscribe({\nnext: (v) =&gt; console.log(&#39;observerB: &#39; + v),\n});\n\n// 透過 next 推送值給所有訂閱者\nsubject.next(1);\nsubject.next(2);\n\n// observerA: 1\n// observerB: 1\n// observerA: 2\n// observerB: 2</code>\n        </deckgo-highlight-code>\n<ul>\n<li>Observer：Subject 可以傳給 Observable 做訂閱\nps. 觀察者無法判斷 Observable 執行是來自普通的 Observable 還是 Subject</li>\n</ul>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">var subject = new Rx.Subject();\n\n// 註冊到觀察者列表中\nsubject.subscribe({\nnext: (v) =&gt; console.log(&#39;observerA: &#39; + v),\n});\nsubject.subscribe({\nnext: (v) =&gt; console.log(&#39;observerB: &#39; + v),\n});\n\nvar observable = Rx.Observable.from([1, 2, 3]);\n\nobservable.subscribe(subject);\n\n// observerA: 1\n// observerB: 1\n// observerA: 2\n// observerB: 2\n// observerA: 3\n// observerB: 3</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>還有一些特殊類型的 Subject 變體：BehaviorSubject、ReplaySubject、AsyncSubject\n_ <a href=\"https://jsbin.com/xizatojawe/1/edit?js,console\" target=\"_blank\" rel=\"nofollow\">BehaviorSubject</a>(initialCurrentValue)\n有當前值，當有新的 Observer 訂閱時，會立即接收到 BehaviorSubject 推送的當前值\n_ <a href=\"https://jsbin.com/lukodifere/1/edit?js,console\" target=\"_blank\" rel=\"nofollow\">ReplaySubject</a>(bufferCount, windowTime/ms)\n記錄 Observable 執行中的多個值並將其回放推送給新訂閱者，可選擇性給限定內時間 * <a href=\"https://jsbin.com/mopalabilo/1/edit?js,console\" target=\"_blank\" rel=\"nofollow\">AsyncSubject()</a>\n當 Observable 執行完成時<code>complete()</code>，將執行的最後一個值發送給觀察者</p>\n<div class=\"warning\">\n單播的 Observable 只會發送值給單個 Observer；若想做到多播，可以將多個訂閱者（Observer）加到 Subject，通過 Subject 發送通知以達到\n→ 使得多個觀察者可以看見同一個Observable 執行\n→ 這也是 multicast 操作符底層的工作原理\n</div>\n</li>\n</ul>\n<h4>Operator <code>multicast(subject)</code></h4>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">var source = Rx.Observable.from([1, 2, 3]);\nvar subject = new Rx.Subject();\nvar multicasted = source.multicast(subject);\n\n// multicast 返回的 ConnectableObservable 是有 connect() 方法的 Observable\n// subscribe 跟 subject 一樣是加訂閱清單但不執行\nmulticasted.subscribe({\n  next: (v) =&gt; console.log(&#39;observerA: &#39; + v),\n});\nmulticasted.subscribe({\n  next: (v) =&gt; console.log(&#39;observerB: &#39; + v),\n});\n\n// connect() 決定執行時機，返回的是 Subscription Connect\nmulticasted.connect();</code>\n        </deckgo-highlight-code>\n<p>情境：<a href=\"https://jsbin.com/mifumopeji/1/edit?js,console\" target=\"_blank\" rel=\"nofollow\">jsbin\n</a> → 以 <code>connect()</code> 顯示調用開啟共享的執行</p>\n<ol>\n<li>第一個觀察者訂閱了多播 Observable</li>\n<li>多播 Observable 已連接</li>\n<li>next 值 0 發送給第一個觀察者</li>\n<li>第二個觀察者訂閱了多播 Observable</li>\n<li>next 值 1 發送給第一個觀察者</li>\n<li>next 值 1 發送給第二個觀察者</li>\n<li>第一個觀察者取消了多播 Observable 的訂閱</li>\n<li>next 值 2 發送給第二個觀察者</li>\n<li>第二個觀察者取消了多播 O bservable 的訂閱</li>\n<li>多播 Observable 的連接已中斷(底層進行的操作是取消訂閱)</li>\n</ol>\n<p>以上情境可以用 ConnectableObservable 的 <code>refCount()</code> 自動化實現：當有第一個訂閱者訂閱時，多播 Observable 會自動啟動執行，並當最後一個訂閱者退訂時，自動停止執行 <a href=\"https://jsbin.com/wijeyovano/1/edit?js,console\" target=\"_blank\" rel=\"nofollow\">jsbin</a></p>\n<h4><a href=\"https://rxjs-dev.firebaseapp.com/guide/scheduler\" target=\"_blank\" rel=\"nofollow\">Scheduler</a></h4>\n<ul>\n<li>忘記 Event loop 的可以 <a href=\"https://hackmd.io/mU49WAgDSVWvcSB6n8vmmA\" target=\"_blank\" rel=\"nofollow\">HackMD</a> 回憶</li>\n<li>Observable 可以同時處理同步和非同步行為，也因此容易搞不清處現在的 observable 執行方式是同步還是非同步、什麼時候開始發送元素，而 Scheduler 可以處理這問題</li>\n<li>Scheduler 控制一個 Observable 的訂閱什麼時候開始，以及發送元素什麼時候送達</li>\n<li>\n<p>扮演三角色</p>\n<ol>\n<li>是一種資料結構，知道如何根據優先級或其他標準來儲存並佇列任務</li>\n<li>是一個執行環境，決定任務何時何地被執行，可以立即、在 callback 中、在 setTimeout 中、在 animation frame 中執行</li>\n<li>是一個虛擬時鐘，透過<code>now()</code>提供了時間的概念，讓任務在特定的時間點被執行</li>\n</ol>\n</li>\n<li>Observable 使用的 Operator，各自都帶有預設不同的 Scheduler，例如無限的 Observable 預設 <code>queue</code>；timer 相關的預設 <code>async</code></li>\n<li>\n<p>RxJS 5 當中有提供四個 Scheduler (queue, asap, async, animationFrame)</p>\n<ul>\n<li><code>queue</code></li>\n<li>和預設立即執行差在當使用到遞迴 Operator 時，會是佇列這些行為而非立即執行</li>\n<li>適合用在會有遞回的 operator 且具有大量資料時使用，能避免不必要的效能損耗</li>\n<li>對應到 event loop 的 <code>Sync queue</code></li>\n<li><code>asap</code></li>\n<li>是非同步的執行，在瀏覽器其實就是 setTimeout 設為 0 秒 (在 NodeJS 中是用 process.nextTick)</li>\n<li>對應到 event loop 的 <code>Micro Task</code></li>\n<li><code>async</code></li>\n<li>它跟 asap 很像但是使用 setInterval 來運作，通常是跟時間相關的 operator 才會用到（RxJS 5 新增的）</li>\n<li>對應到 event loop 的 <code>Macro Task</code></li>\n<li><code>animationFrame</code></li>\n<li>利用 Window.requestAnimationFrame 來實作的</li>\n</ul>\n</li>\n<li>利用 <code>observeOn</code> 和 <code>subscribeOn</code> 指定每次發送值的時機、訂閱時機</li>\n</ul>\n<p>範例</p>\n<ul>\n<li>Rx.Observable.from([1,2,3,4,5]).<a href=\"https://jsbin.com/gewazatepo/edit?js,console\" target=\"_blank\" rel=\"nofollow\"><code>observeOn(Rx.Scheduler.async)</code></a>\n可讓原本是同步執行的 Observable 就變成了非同步執行</li>\n<li>除了 <code>observeOn()</code> 以外，Creation Operators 如 <code>from</code>, <code>of</code>, <code>merge</code>, <code>concat</code>, <code>timer</code>, <code>interval</code>... 的最後一位參數都可以接受 Scheduler</li>\n<li>有無設 delay 的行為模式有差 - <a href=\"https://codesandbox.io/s/rxjs-playground-ci6z5?fontsize=14\" target=\"_blank\" rel=\"nofollow\">CodeSandBox</a></li>\n</ul>\n<hr>\n<h3>redux-observable</h3>\n<ul>\n<li>前端 react 所用的 <code>redux-observable</code> 是 Netflix 開源的用 RxJS 來處理非同步行為的方式</li>\n<li>\n<p>導入 redux-observable 的 react redux 專案中的所有 action 都會通過 middleware，可以在 middleware 裡加上多個 Epic（dispatch action 時觸發），每一個 Epic（action stream）就是一個 Observable，可以監聽指定的 action 做轉換處理，並確保最後回傳的是 action 就會被送到 reducer。</p>\n<blockquote>\n<p>Epic: actions in, actions out function</p>\n</blockquote>\n</li>\n</ul>\n<p><img src=\"https://i.imgur.com/421jYIJ.png\"></p>\n<p>React Redux 導入 redux-observable</p>\n<ul>\n<li>redux-observable 提供 <code>ofType</code> operator 來篩選 action stream 中特定的 action</li>\n<li>\n<p>先提一下 <code>fromPromise</code> 和 <code>defer</code> Operator</p>\n<ul>\n<li><code>fromPromise</code> 接受 Promise 轉為 Observable，接受 Promise 時就會執行該 Promise。若想要當 Promise 被消費時才執行就需要使用 <code>defer</code></li>\n<li><code>defer</code> 是<strong>惰性</strong>創建操作符\n<img src=\"https://i.imgur.com/fDgDZZL.png\">\n接收創建 Observable 的函數，當消費方需要 Observable 時被調用才會創建一個 Observable，並從中取得數據操作（defer 定義當下還不存在 Observable）</li>\n</ul>\n</li>\n<li>\n<p>將 Epic 掛進 store 的 middleware 中，這樣 dispatch action 時就會觸發 Epic 事件\n<a href=\"https://redux-observable.js.org/docs/basics/SettingUpTheMiddleware.html\" target=\"_blank\" rel=\"nofollow\">Setting Up The Middleware</a></p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">// 1. 需要用 redux-observable 創建 middleware\nimport { combineEpics, createEpicMiddleware } from &#39;redux-observable&#39;;\nconst epicMiddleware = createEpicMiddleware();\n\n// 2. 這個 epicMiddleware 可以吃多個 Epic 的集合\nconst rootEpic = combineEpics(可以是很多個Epic的argument);\n\n// 3. 然後在 redux create Store 時採用此 epicMiddleware\nconst store = createStore(rootReducer, applyMiddleware(epicMiddleware));\n// 4.\nepicMiddleware.run(rootEpic);\n\nexport default store;</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h2>Notes</h2>\n<ol>\n<li>componentWillUnmount 時記得要 unsubscribe Observables 避免 memory lock</li>\n<li>若多個 Observer 要訂閱同一 Observable 可以利用 Subject</li>\n<li>Subject 既是 Observable 也是 Observer</li>\n<li>有可以調整執行條件的 Scheduler 存在</li>\n</ol>\n<h2>References</h2>\n<ul>\n<li><a href=\"https://rxjs-dev.firebaseapp.com/guide/overview\" target=\"_blank\" rel=\"nofollow\">RxJS Guide</a></li>\n<li><a href=\"https://cn.rx.js.org/manual/overview.html#h14\" target=\"_blank\" rel=\"nofollow\">教程| RxJS 中文文档</a></li>\n<li><a href=\"https://www.robinwieruch.de/redux-observable-rxjs\" target=\"_blank\" rel=\"nofollow\">Redux Observable RxJS: Going Epic with Reactive Programming</a></li>\n<li><a href=\"https://blog.kevinyang.net/2018/08/31/rxjs-scheduler/\" target=\"_blank\" rel=\"nofollow\">[RxJS] Scheduler</a></li>\n<li><a href=\"https://ithelp.ithome.com.tw/articles/10225565?sc=rss.iron\" target=\"_blank\" rel=\"nofollow\">【Day 22】redux-observable</a></li>\n<li><a href=\"https://redux-observable.js.org/docs/basics/Epics.html\" target=\"_blank\" rel=\"nofollow\">Epics · redux-observable</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=DPyZq74V60o&#x26;list=PL9LUW6O9WZqgUMHwDsKQf3prtqVvjGZ6S&#x26;index=17\" target=\"_blank\" rel=\"nofollow\">[S05E06] RxJS 運算子全面解析</a></li>\n<li><a href=\"https://medium.com/@jdjuan/mouse-drag-with-rxjs-45861c4d0b7e\" target=\"_blank\" rel=\"nofollow\">Mouse Drag with RxJS</a></li>\n</ul>","timeToRead":11,"frontmatter":{"title":"初探 RxJS（下）","date":"25 Nov 2019","tags":["rxjs"],"path":"blog/20191125","excerpt":"簡介上次未完的 RxJS 剩餘角色，和介紹目前公司後台專案使用的 redux-observable。"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"blog/20210110","title":"Pop Quiz","tags":["javascript"],"excerpt":"記錄踩到的陷阱題。"}}},{"node":{"frontmatter":{"path":"blog/20210109-3","title":"REST / RESTful & HTTP Methods","tags":["javascript"],"excerpt":"簡易整理。"}}},{"node":{"frontmatter":{"path":"blog/20191107","title":"Javascript Event loop - macro task & micro task","tags":["javascript"],"excerpt":"介紹 Event loop 容易混淆的異步任務 macro task & micro task。"}}},{"node":{"frontmatter":{"path":"blog/20210109","title":"Response Set-Cookie 無效","tags":["apollo"],"excerpt":"記錄個之前在和同事們弄 Side project 時犯蠢遇到的問題與解決方式。"}}},{"node":{"frontmatter":{"path":"blog/20200518","title":"常用 NoSQL 雲端資料庫 - Part 1 MongoDB","tags":["mongodb"],"excerpt":"簡介 Relational/NoSQL database、mongoose ORM 寫 mongo CRUD API。"}}},{"node":{"frontmatter":{"path":"blog/20180521","title":"Web 常見攻擊手法","tags":["security"],"excerpt":"擁有基本的資安觀念保護好自家資料和 user 使用環境是開發人員重要的一點。"}}},{"node":{"frontmatter":{"path":"blog/20190707","title":"JavaScript HTML5 Web Worker & CRA 使用踩雷","tags":["javascript"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20180514","title":"JavaScript 中 this 指向","tags":["javascript"],"excerpt":"簡介 this 指向的六種情況。"}}},{"node":{"frontmatter":{"path":"blog/20190108","title":"JavaScript 認識非同步 Callback, Promise, async/await","tags":["javascript"],"excerpt":"Asynchronous 非同步的不同寫法的整理筆記。"}}},{"node":{"frontmatter":{"path":"blog/20170728","title":"WebForm 註冊 JavaScript","tags":["asp.net","javascript"],"excerpt":"動態產生JS在目前公司專案中是滿常用到的小技巧，不同的用法會產生在Web Page 的不同位置而有直譯式語言的前後順序差。"}}},{"node":{"frontmatter":{"path":"blog/20170714","title":"WebForm 使用 reCAPTCHA 驗證","tags":["asp.net"],"excerpt":"這個我不是機器人驗證一定不陌生，滿多登入畫面會看到的，剛好今天接到把圖形驗證改為 reCAPTCHA 就順手記下。"}}},{"node":{"frontmatter":{"path":"blog/20170604","title":"Web App 推播通知","tags":["asp.net"],"excerpt":"隨著行動和穿載裝置的興起，推播通知 (Push Notification) 成為維繫App用戶關係相當有力的工具"}}},{"node":{"frontmatter":{"path":"blog/20190906","title":"初探 Storybook","tags":["javascript"],"excerpt":"初探這款能夠在開發前端元件或是函式庫的同時，可以快速地建立元件各種操作模式或是樣式的工具。"}}},{"node":{"frontmatter":{"path":"blog/20170421","title":"存取遠端 EventLog","tags":["asp.net","javascript"],"excerpt":"在公司中實作一個 Event log 的查詢工具。（之後來寫了 D3 呈現查詢異常查詢的部分）"}}},{"node":{"frontmatter":{"path":"blog/20170508","title":"WebForm 圖片上傳檢查","tags":["asp.net"],"excerpt":"開放上傳有可能被傳奇怪東西的風險，只檢查所看到的副檔名，謹慎來說似乎是不夠的。"}}},{"node":{"frontmatter":{"path":"blog/20210109-2","title":"IntersectionObserver","tags":["javascript"],"excerpt":"公司專案有個日期連動的 scroll 優化試驗，原先是監聽 scroll。"}}},{"node":{"frontmatter":{"path":"blog/20200630","title":"Express - Authentication, Authorization and Security","tags":["security","express"],"excerpt":"簡介 Express RESTful API Server 範例中 JWT 權限、授權相關。"}}},{"node":{"frontmatter":{"path":"blog/20200910","title":"Apollo Server 入門篇","tags":["apollo"],"excerpt":"快速複習去年分享的 GraphQL Schema 和 Client query 語法，並簡介如何以 Apollo Server 建立 GraphQL Server。"}}},{"node":{"frontmatter":{"path":"blog/20200527","title":"常用 NoSQL 雲端資料庫 - Part 2 Firebase","tags":["firebase"],"excerpt":"簡介 Google 提供的後端服務平臺（BaaS）中的兩種 DB，realtime database 和 cloud firestore。"}}},{"node":{"frontmatter":{"path":"blog/20190906-2","title":"React Hooks - useCallback, useMemo, useRef","tags":["reactjs"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20190907","title":"GraphQL & Apollo Client","tags":["apollo"],"excerpt":"簡單介紹 React Client 端如何用 Apollo 對 GraphQL Server 做資料存取操作。"}}},{"node":{"frontmatter":{"path":"blog/20191017","title":"初探 RxJS（上）","tags":["rxjs"],"excerpt":"簡介相關的設計模式中的 Behavioral Pattern，再介紹 RxJS（先講 Observable）"}}},{"node":{"frontmatter":{"path":"blog/20190909","title":"Prisma - Schema, Data Model, Relations, Client","tags":["prisma"],"excerpt":"未來 Side project 可能會應用到的 SDL first 開發流程角度，簡介此可以取代傳統 ORM 的 DB toolkit。"}}}]}},"pageContext":{"postPath":"blog/20191125","translations":[{"hreflang":"en","path":"/blog/20191125"}]}},"staticQueryHashes":["4097791827"]}