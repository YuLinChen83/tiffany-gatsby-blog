{"componentChunkName":"component---src-templates-post-post-jsx","path":"/blog/20190108","result":{"data":{"markdownRemark":{"html":"<p>由於到目前為止的工作上都沒什麼機會用到，想好好了解一下非同步（Asynchronous）的不同寫法（Callback, Promise, async/await）所以在 Study 後整理個筆記。</p>\n<h2>Callback</h2>\n<p>把 A function 傳進 B function，當 B 做完事後才執行 A。若事件是多個 callback 下來便會淪落那張波動圖 callback 地獄 XD</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">function dynamicDOM(result) {\n  // render DOM by result\n}\n\nfunction getUserList(cb) {\n  $.ajax(apiUrl, {}).done(cb(result));\n}\n\ngetUserList(dynamicDOM);</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">const renderMembers = (members) =&gt; {\n  // render DOM by members\n};\n\nconst fetchMembers = (companyName) =&gt; {\n  fetch(`${apiUrl}?company=${companyName}`, {\n    method: &#39;GET&#39;,\n  })\n    .then((res) =&gt; res.json())\n    .then((result) =&gt; {\n      cb(result);\n    })\n    .catch((error) =&gt; console.error(&#39;Error:&#39;, error));\n};\nfetchMember(&#39;Google&#39;, renderMembers);</code>\n        </deckgo-highlight-code>\n<h2>Promise</h2>\n<p>定義 Promise 傳入 resolve 與 reject 表示資料成功與失敗，透過 then, catch 來回傳結果，方法內執行同時並不會影響其他函式的運行。</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">let runPromise = (someone, timer, success = true) =&gt; {\n  console.log(`${someone} 跑程式`);\n  return new Promise((resolve, reject) =&gt; {\n    if (success) {\n      setTimeout(function() {\n        resolve(`${someone} 的程式執行了 ${timer / 1000} 秒時間`);\n      }, timer);\n    } else {\n      reject(`${someone} 的程式無法執行`);\n    }\n  });\n};\n\nrunPromise(&#39;Tiffany&#39;, 3000)\n  .then((result) =&gt; {\n    console.log(result);\n  })\n  .catch((error) =&gt; {\n    console.log(error);\n  });\n\nconsole.log(&#39;Promise 結束前就會執行這&#39;);</code>\n        </deckgo-highlight-code>\n<h2>Await</h2>\n<p>承上定義好的 runPromise， Promise 結束前，後面的程式碼都無法被執行，且中間 await 的若是 reject 將不會知道而程式終止在那。</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">let tiffanyRun = await runPromise(&#39;Tiffany&#39;, 2000);\nconsole.log(&#39;執行完成:&#39;, tiffanyRun);\nlet benRun = await runPromise(&#39;Ben&#39;, 2500);\nconsole.log(&#39;執行完成:&#39;, benRun);</code>\n        </deckgo-highlight-code>\n<p>await 也可以和 Promise.all() 共用，一樣若是 reject 將不會知道而程式終止在那；若皆 resolve 會得到 resolve 值的陣列。</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">let allRun = await Promise.all([runPromise(&#39;Tiffany&#39;, 3000), runPromise(&#39;Ben&#39;, 2500)]);\nconsole.log(allRun);</code>\n        </deckgo-highlight-code>\n<h2>Await/Async</h2>\n<p>用 Async 包裝好後就可以像是用同步程式呼叫它，且 await 的錯誤會讓 async 拋出錯誤（await 錯誤的 rejected），而不會造成終止。\nAsync 的結構就類似將 await 包在裡面 Promise。Async/Await 使得程式碼更簡潔容易閱讀。</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">const asyncRun = async () =&gt; {\n  // await Promise 的值為 resolve 的內容\n  let tiffanyRun = await runPromise(&#39;Tiffany&#39;, 2000);\n  let benRun = await runPromise(&#39;Ben&#39;, 2500);\n  return `${tiffanyRun}, ${benRun}`;\n};\nasyncRun()\n  .then((response) =&gt; {\n    console.log(response);\n  })\n  .catch((error) =&gt; {\n    console.log(error);\n  });</code>\n        </deckgo-highlight-code>\n<p>當 async 內皆 resolve，asyncRun 視為 resolve Promise，若 await 中被 reject 則會視為 reject Promise 自動把該 await 的 reject 拋給 async。\nasync 最後 return 的值為 .then() 所接的值。<br>\n若想在 async/await 內攔截其中某 await Promise 的 reject 並做處理以讓程式繼續可用 try catch。可看 Codepen Example。</p>\n<h2>Notes</h2>\n<ol>\n<li>async/await func 通常以目的命名</li>\n<li>async/await func 定義前面要加上 async ( 變成回傳 Promise )</li>\n<li>async/await func 內所有回傳 Promise 的非同函數前面都可以加上 await，被加上時就會等到 resolve value 出現程式才會往下走</li>\n</ol>\n<h2>References</h2>\n<p><a href=\"https://wcc723.github.io/javascript/2017/12/30/javascript-async-await/\" target=\"_blank\" rel=\"nofollow\">鐵人賽：JavaScript Await 與 Async</a>\n<a href=\"https://ithelp.ithome.com.tw/articles/10201420\" target=\"_blank\" rel=\"nofollow\">Day 14 – 二周目 – 從 Promise 昇華到 async/await</a></p>","timeToRead":2,"frontmatter":{"title":"JavaScript 認識非同步 Callback, Promise, async/await","date":"08 Jan 2019","tags":["javascript"],"path":"blog/20190108","excerpt":"Asynchronous 非同步的不同寫法的整理筆記。"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"blog/20210813","title":"面試技術","tags":["reactjs"],"excerpt":null}}},{"node":{"frontmatter":{"path":"blog/20210725-2","title":"SVGR 設置","tags":["javascript"],"excerpt":"webpack loader 以 Component 方式使用 Svg。"}}},{"node":{"frontmatter":{"path":"blog/20210813","title":"Redux 處理 Async Actions","tags":["reactjs"],"excerpt":"簡介 Redux Observable、Redux Saga、Redux Thunk。"}}},{"node":{"frontmatter":{"path":"blog/20210109-2","title":"IntersectionObserver","tags":["javascript"],"excerpt":"公司專案有個日期連動的 scroll 優化試驗，原先是監聽 scroll。"}}},{"node":{"frontmatter":{"path":"blog/20210110","title":"Pop Quiz","tags":["javascript"],"excerpt":"記錄踩到的陷阱題。"}}},{"node":{"frontmatter":{"path":"blog/20200910","title":"Apollo Server 入門篇","tags":["apollo"],"excerpt":"快速複習去年分享的 GraphQL Schema 和 Client query 語法，並簡介如何以 Apollo Server 建立 GraphQL Server。"}}},{"node":{"frontmatter":{"path":"blog/20200518","title":"常用 NoSQL 雲端資料庫 - Part 1 MongoDB","tags":["mongodb"],"excerpt":"簡介 Relational/NoSQL database、mongoose ORM 寫 mongo CRUD API。"}}},{"node":{"frontmatter":{"path":"blog/20200527","title":"常用 NoSQL 雲端資料庫 - Part 2 Firebase","tags":["firebase"],"excerpt":"簡介 Google 提供的後端服務平臺（BaaS）中的兩種 DB，realtime database 和 cloud firestore。"}}},{"node":{"frontmatter":{"path":"blog/20210109-3","title":"REST / RESTful & HTTP Methods","tags":["javascript"],"excerpt":"簡易整理。"}}},{"node":{"frontmatter":{"path":"blog/20210725","title":"初試 SonarQube","tags":["tool"],"excerpt":"記錄下認識的新東西。"}}},{"node":{"frontmatter":{"path":"blog/20200630","title":"Express - Authentication, Authorization and Security","tags":["security","express"],"excerpt":"簡介 Express RESTful API Server 範例中 JWT 權限、授權相關。"}}},{"node":{"frontmatter":{"path":"blog/20191125","title":"初探 RxJS（下）","tags":["rxjs"],"excerpt":"簡介上次未完的 RxJS 剩餘角色，和介紹目前公司後台專案使用的 redux-observable。"}}},{"node":{"frontmatter":{"path":"blog/20190909","title":"Prisma - Schema, Data Model, Relations, Client","tags":["prisma"],"excerpt":"未來 Side project 可能會應用到的 SDL first 開發流程角度，簡介此可以取代傳統 ORM 的 DB toolkit。"}}},{"node":{"frontmatter":{"path":"blog/20191107","title":"Javascript Event loop - macro task & micro task","tags":["javascript"],"excerpt":"介紹 Event loop 容易混淆的異步任務 macro task & micro task。"}}},{"node":{"frontmatter":{"path":"blog/20190907","title":"GraphQL & Apollo Client","tags":["apollo"],"excerpt":"簡單介紹 React Client 端如何用 Apollo 對 GraphQL Server 做資料存取操作。"}}},{"node":{"frontmatter":{"path":"blog/20190906","title":"初探 Storybook","tags":["javascript"],"excerpt":"初探這款能夠在開發前端元件或是函式庫的同時，可以快速地建立元件各種操作模式或是樣式的工具。"}}},{"node":{"frontmatter":{"path":"blog/20210109","title":"Response Set-Cookie 無效","tags":["apollo"],"excerpt":"記錄個之前在和同事們弄 Side project 時犯蠢遇到的問題與解決方式。"}}},{"node":{"frontmatter":{"path":"blog/20190906-2","title":"React Hooks - useCallback, useMemo, useRef","tags":["reactjs"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20190707","title":"JavaScript HTML5 Web Worker & CRA 使用踩雷","tags":["javascript"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20180521","title":"Web 常見攻擊手法","tags":["security"],"excerpt":"擁有基本的資安觀念保護好自家資料和 user 使用環境是開發人員重要的一點。"}}},{"node":{"frontmatter":{"path":"blog/20191017","title":"初探 RxJS（上）","tags":["rxjs"],"excerpt":"簡介相關的設計模式中的 Behavioral Pattern，再介紹 RxJS（先講 Observable）"}}},{"node":{"frontmatter":{"path":"blog/20180514","title":"JavaScript 中 this 指向","tags":["javascript"],"excerpt":"簡介 this 指向的六種情況。"}}},{"node":{"frontmatter":{"path":"blog/20170714","title":"WebForm 使用 reCAPTCHA 驗證","tags":["asp.net"],"excerpt":"這個我不是機器人驗證一定不陌生，滿多登入畫面會看到的，剛好今天接到把圖形驗證改為 reCAPTCHA 就順手記下。"}}},{"node":{"frontmatter":{"path":"blog/20170604","title":"Web App 推播通知","tags":["asp.net"],"excerpt":"隨著行動和穿載裝置的興起，推播通知 (Push Notification) 成為維繫App用戶關係相當有力的工具"}}},{"node":{"frontmatter":{"path":"blog/20170508","title":"WebForm 圖片上傳檢查","tags":["asp.net"],"excerpt":"開放上傳有可能被傳奇怪東西的風險，只檢查所看到的副檔名，謹慎來說似乎是不夠的。"}}},{"node":{"frontmatter":{"path":"blog/20170728","title":"WebForm 註冊 JavaScript","tags":["asp.net","javascript"],"excerpt":"動態產生JS在目前公司專案中是滿常用到的小技巧，不同的用法會產生在Web Page 的不同位置而有直譯式語言的前後順序差。"}}},{"node":{"frontmatter":{"path":"blog/20170421","title":"存取遠端 EventLog","tags":["asp.net","javascript"],"excerpt":"在公司中實作一個 Event log 的查詢工具。（之後來寫了 D3 呈現查詢異常查詢的部分）"}}}]}},"pageContext":{"postPath":"blog/20190108","translations":[{"hreflang":"en","path":"/blog/20190108"}]}},"staticQueryHashes":["4097791827"]}