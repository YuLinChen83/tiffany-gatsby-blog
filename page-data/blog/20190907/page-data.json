{"componentChunkName":"component---src-templates-post-post-jsx","path":"/blog/20190907","result":{"data":{"markdownRemark":{"html":"<h2>RESTful</h2>\n<ul>\n<li>資源相依：一個 URL 只能獲取特定資源，結構鬆散問題導致多條件查詢得創造多個 URL</li>\n<li>回傳的內容格式無法預期</li>\n<li>沒有文件（但可用 <a href=\"https://stoplight.io/docs/\" target=\"_blank\" rel=\"nofollow\">Stoplight</a> 去做 API 文件另外維護更新）</li>\n<li>在 React 內資料放在 Redux</li>\n<li>例：<code>GET /resource/{:id}/relation/{:relation_id}</code></li>\n</ul>\n<h2><a href=\"https://graphql.cn/\" target=\"_blank\" rel=\"nofollow\">GraphQL</a></h2>\n<p><img src=\"https://i.imgur.com/3Vp0YJx.png\"></p>\n<blockquote>\n<p>一種用於 API 的查詢語言，主要使用於應用服務之間的溝通（尤其是前後端）\n<a href=\"https://graphql.cn/learn/queries/\" target=\"_blank\" rel=\"nofollow\">Learn GraphQL</a>\n:::warning\n<strong>GraphQL Server</strong>\n架構： Schema 定義 GraphQL API 的輪廓及規範\n行為： Resolver 負責資料取得的實作（Query，Mutation⋯⋯）\n:::</p>\n</blockquote>\n<ol>\n<li>行動裝置普及</li>\n<li>資料邏輯複雜</li>\n<li>Micro service 崛起</li>\n</ol>\n<p><img src=\"https://i.imgur.com/NKDVcWM.png\"></p>\n<p>優點</p>\n<ul>\n<li>可以通過一次請求就獲取所需的所有數據</li>\n<li>程式即文檔</li>\n<li>\n<p>一些特性：</p>\n<ul>\n<li>宣告式 (Declarative) 資料索取</li>\n<li>Scalar type 強型別：Int, Float, String, Boolean, ID</li>\n</ul>\n</li>\n<li>原先為 fb 內部使用，現有知名使用站 Github、Reddit、Shopify、Twitter</li>\n<li>\n<p>很多線上 Playground</p>\n<ul>\n<li><a href=\"https://www.graphqlbin.com/v2/mqZgc5\" target=\"_blank\" rel=\"nofollow\">GraphQL Playground</a></li>\n<li><a href=\"https://lucasconstantino.github.io/graphiql-online/\" target=\"_blank\" rel=\"nofollow\">GraphiQL</a></li>\n</ul>\n</li>\n<li><a href=\"https://www.graphqlhub.com/\" target=\"_blank\" rel=\"nofollow\">GraphQLHub</a> 一些大公司的公開 GraphQL api 可參考</li>\n</ul>\n<p>缺點</p>\n<ul>\n<li>容易不小心陷入 RESTful API 的設計思維，埋下更多技術債</li>\n<li>預設 Error Handling 的 GraphQL errors 全部都是 runtime errors（資料拿不到）</li>\n</ul>\n<h2>RESTful vs GraphQL</h2>\n<table>\n<thead>\n<tr>\n<th align=\"center\">RESTful</th>\n<th align=\"center\">GraphQL</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">通常好幾個 Endpoint</td>\n<td align=\"center\">單一 Endpoint 入口</td>\n</tr>\n<tr>\n<td align=\"center\">Request 次數多（橫跨多資源時）</td>\n<td align=\"center\">Request 次數少（大部份時候)</td>\n</tr>\n<tr>\n<td align=\"center\">API 回你什麼就是什麼</td>\n<td align=\"center\">回傳資料相對可預期</td>\n</tr>\n<tr>\n<td align=\"center\">文件維護麻煩</td>\n<td align=\"center\">可做到 Schema 即文件</td>\n</tr>\n</tbody>\n</table>\n<h2><a href=\"https://ithelp.ithome.com.tw/articles/10209136\" target=\"_blank\" rel=\"nofollow\">Apollo Client</a></h2>\n<ul>\n<li>\n<p>Apollo Client 是 JavaScript 應用程式的 <strong>狀態管理庫</strong>，可存取 GraphQL server 資料，也有 cache 機制。\n不用 redux 繁瑣的 action, reducer, dispatch 就能讓全局管理 store 變得簡單直白，並專注在規劃所需要的數據。</p>\n<blockquote>\n<p>Intelligent <code>caching</code> and declarative approach to data <code>fetching</code> can help you iterate faster while writing less code.</p>\n</blockquote>\n</li>\n<li>\n<p><code>Apollo</code> 是社群驅動開發的 GraphQL client，容易理解、可拓展性強，功能強大，可以在主流開發平臺上面使用。</p>\n<ul>\n<li>補：<code>Relay</code> 則是由 Facebook 開發的開源的 GraphQL Client，功能豐富並且做了很多效能優化，由於是一個大而全的庫，學習難度比較大。</li>\n</ul>\n</li>\n<li>想引入現有 React &#x26; Redux 專案的話可參考 <a href=\"https://s3.amazonaws.com/apollo-docs-1.x/redux.html\" target=\"_blank\" rel=\"nofollow\">Graph + React + Redux</a></li>\n</ul>\n<h3>Why Apollo Client?</h3>\n<ol>\n<li>聲明式存取資料</li>\n<li>內建 caching 機制</li>\n<li>強大社群開發</li>\n</ol>\n<h4>Declarative data fetching - <code>useQuery</code> /<code>useLazyQuery</code> hook</h4>\n<blockquote>\n<p>Retrieving your data, tracking loading and error states, and updating your UI.[color=pink]</p>\n</blockquote>\n<p><strong><a href=\"https://www.apollographql.com/docs/react/essentials/queries/#options\" target=\"_blank\" rel=\"nofollow\">useQuery</a></strong> Apollo Client 會在 React mounts 和 renders 自動 query</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">function Feed() {\n  const { loading, error, data } = useQuery(GET_DOGS);\n  if (error) return &lt;Error /&gt;;\n  if (loading || !data) return &lt;Fetching /&gt;;\n\n  return &lt;DogList dogs={data.dogs} /&gt;;\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>\n<p>用 render props 寫法如下</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">const Feed = () =&gt; (\n&lt;Query query={GET_DOGS}&gt;\n  {({ loading, error, data }) =&gt; {\n    if (error) return &lt;Error /&gt;;\n    if (loading || !data) return &lt;Fetching /&gt;;\n\n    return &lt;DogList dogs={data.dogs} /&gt;;\n  }}\n&lt;/Query&gt;\n);</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p>hooks 寫法較 render props 寫法乾淨易讀</p>\n<p>如果想要藉由 event 觸發 query (ex. onClick) 則可以用 <strong>useLazyQuery</strong></p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">import React from &#39;react&#39;;\nimport { useLazyQuery } from &#39;@apollo/react-hooks&#39;;\n\nfunction DelayedQuery() {\n  const [dog, setDog] = useState(null);\n  const [getDog, { loading, data }] = useLazyQuery(GET_DOG_PHOTO);\n\n  if (loading) return &lt;p&gt;Loading ...&lt;/p&gt;;\n\n  if (data &amp;&amp; data.dog) {\n    setDog(data.dog);\n  }\n\n  return (\n    &lt;div&gt;\n      {dog &amp;&amp; &lt;img src={dog.displayImage} /&gt;}\n      &lt;button onClick={() =&gt; getDog({ variables: { breed: &#39;bulldog&#39; } })}&gt;Click me!&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<h4>Zero-config caching</h4>\n<blockquote>\n<p>Just by setting up Apollo Client, you get an intelligent cache out of the box with no additional configuration required.[color=pink]</p>\n</blockquote>\n<ul>\n<li><a href=\"https://xbuba.com/questions/52927310\" target=\"_blank\" rel=\"nofollow\"><code>cacheRedirects</code></a> 告訴 Apollo 如何從其他查詢訪問已經在緩存中的數據</li>\n</ul>\n<h4>Combine local &#x26; remote data</h4>\n<blockquote>\n<p>You can add client-side only fields to your remote data seamlessly and query them from your components.[color=pink]</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.apollographql.com/docs/react/essentials/local-state/\" target=\"_blank\" rel=\"nofollow\">Local state management</a></li>\n</ul>\n<deckgo-highlight-code javascript=  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">const GET_DOG = gql`\n  query GetDogByBreed($breed: String!) {\n    dog(breed: $breed) {\n      images {\n        url\n        id\n        isLiked @client\n      }\n    }\n  }\n`;</code>\n        </deckgo-highlight-code>\n<h4>Vibrant ecosystem</h4>\n<h2>Learn Apollo Client (React hooks)</h2>\n<ul>\n<li>\n<p>gql query: 其實就是選取 Object 的 field 來獲取資料</p>\n<ul>\n<li>The <code>operation type</code> is either query, mutation, or subscription.</li>\n<li>The <code>operation name</code> is a meaningful and explicit name for your operation.</li>\n<li>增加可讀性、表達性</li>\n<li>若一次執行多筆 operation， Query Name 有助於區分各個 operation</li>\n<li>debug 或是效能追蹤才好找</li>\n<li>All <code>declared variables</code> must be either scalars(Int, Float, String, Boolean, ID), enums, or input object types.</li>\n<li><img src=\"https://i.imgur.com/pCmNYXy.png\"></li>\n<li><img src=\"https://i.imgur.com/bDie7WZ.png\"></li>\n<li>需注意：<strong>Input Object Type</strong> 與 <strong>Object Type</strong> 完全不同，一個是傳入 Argument 作為 Input ，一個是用於資料索取展示</li>\n</ul>\n</li>\n<li>\n<h3><a href=\"https://graphql.org/learn/queries/\" target=\"_blank\" rel=\"nofollow\">Queries</a> - useQuery hooks</h3>\n<ul>\n<li><a href=\"https://graphql.org/learn/queries/#using-variables-inside-fragments\" target=\"_blank\" rel=\"nofollow\">Query Example</a></li>\n<li><a href=\"https://www.apollographql.com/docs/react/essentials/queries/#options\" target=\"_blank\" rel=\"nofollow\"><code>useQuery</code></a> 返回 result object，包含 loading, error, data…</li>\n<li>Polling 可定時請求</li>\n<li><code>pollInterval</code></li>\n</ul>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">function DogPhoto({ breed }) {\n  const { loading, error, data } = useQuery(GET_DOG_PHOTO, {\n    variables: { breed },\n    skip: !breed,\n    pollInterval: 500,\n  });\n\n  if (loading) return null;\n  if (error) return `Error! ${error}`;\n\n  return &lt;img src={data.dog.displayImage} style={{ height: 100, width: 100 }} /&gt;;\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">const DogPhoto = ({ breed }) =&gt; (\n  &lt;Query query={GET_DOG_PHOTO} variables={{ breed }} skip={!breed} pollInterval={500}&gt;\n    {({ loading, error, data }) =&gt; {\n      if (loading) return null;\n      if (error) return `Error! ${error}`;\n\n      return &lt;img src={data.dog.displayImage} style={{ height: 100, width: 100 }} /&gt;;\n    }}\n  &lt;/Query&gt;\n);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>Refetching 可執行前次查詢</li>\n<li><code>refetch</code> 可選擇地代新 variables</li>\n<li>但 loading 第一次取得 data 後無用，可藉由 useQuery 第二個參數給 <code>notifyOnNetworkStatusChange: true</code> 設定。<code>networkStatus</code>會是 4</li>\n</ul>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">function DogPhoto({ breed }) {\n  const { loading, error, data, refetch, networkStatus } = useQuery(GET_DOG_PHOTO, {\n    variables: { breed },\n    skip: !breed,\n    notifyOnNetworkStatusChange: true,\n  });\n\n  if ((networkStatus **= 4)) return &#39;Refetching!&#39;;\n  if (loading) return null;\n  if (error) return `Error! ${error}`;\n\n  return (\n    &lt;div&gt;\n      &lt;img src={data.dog.displayImage} style={{ height: 100, width: 100 }} /&gt;\n      &lt;button onClick={() =&gt; refetch()}&gt;Refetch!&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<h3><a href=\"https://www.apollographql.com/docs/react/essentials/mutations/\" target=\"_blank\" rel=\"nofollow\">useMutation</a> - useMutation hooks</h3>\n<ul>\n<li>Mutation = RESTful 的 <code>POST</code>/<code>PUT</code>/<code>PATCH</code></li>\n<li><a href=\"https://graphql.org/learn/queries/#mutations\" target=\"_blank\" rel=\"nofollow\">Mutation Example</a></li>\n<li><a href=\"https://www.apollographql.com/docs/react/essentials/mutations/#options\" target=\"_blank\" rel=\"nofollow\"><code>useMutation</code></a> 返回陣列第一個參數為 mutate function，第二個是 result object，也包含 loading, error, data...</li>\n<li>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">import gql from &#39;graphql-tag&#39;;\nimport { useMutation } from &#39;@apollo/react-hooks&#39;;</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p>const ADD_TODO = gql<code>mutation AddTodo($type: String!) { addTodo(type: $type) { id type } }</code>;</p>\n<p>function AddTodo() {\nlet input;\nconst [addTodo, { data }] = useMutation(ADD_TODO);</p>\n<p>  return (\n<div>\n&#x3C;form\nonSubmit={(e) => {\ne.preventDefault();\naddTodo({ variables: { type: input.value } });\ninput.value = '';\n}}\n>\n&#x3C;input\nref={(node) => {\ninput = node;\n}}\n/>\n<button type=\"submit\">Add Todo</button>\n</form>\n</div>\n);\n}</p>\n<deckgo-highlight-code   terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"undefined\">\n          <code slot=\"code\">- [Updating the cache](https://www.apollographql.com/docs/react/essentials/mutations/#updating-the-cache)\n_ 可以做增刪改後的 cache 變更\n_ 看範例程式\n![](https://i.imgur.com/YgYngRP.png)\n_ apollo graphql 的提取策略是緩存優先，若需要最新數據的查詢，禁止使用 apollo 緩存，則可以配置 `{ fetchPolicy: &quot;network-only&quot; }`\n其他還有\n_ cache-first → (預設)優先找 cache ，找不到才抓\n_ cache-and-network → 先從 cache 顯示，同時抓更新資料\n_ network-only → 無視 cache，永遠從 API 抓\n_ cache-only → 永遠從 cache 拿，拿不到就噴 error\n_ no-cache → 永遠從 API 抓，而且不寫進 cache\n- [Basic optimistic UI](https://www.apollographql.com/docs/react/features/optimistic-ui/#basic-optimistic-ui)\n- **update** 會在 mutation response 回來時被觸發，而 **optimisticRespons** 是在 mutation 前先造假 response update 一次，讓資料先從 cache 中消失</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h2>Packages</h2>\n<ul>\n<li>\n<p>hooks 版和 render prop components 版所需要 npm 的東西不同</p>\n<ul>\n<li>hooks <code>npm install @apollo/react-hooks</code></li>\n<li>will give you the greatest bundle size savings</li>\n<li>render prop <code>npm install @apollo/react-components</code></li>\n<li>HOC <code>npm install @apollo/react-hoc</code></li>\n<li>以上 3 React Apollo paradigms 都要 <code>npm install react-apollo</code></li>\n</ul>\n</li>\n<li>\n<p><code>npm install apollo-boost</code> <a href=\"https://www.apollographql.com/docs/react/essentials/get-started/#configuration-options\" target=\"_blank\" rel=\"nofollow\">設定 option</a></p>\n<ul>\n<li>apollo-boost 包含了下面設置 Apollo Client 所需的核心包\n也可以客制自行選擇安裝單獨的包\n_ apollo-client：Apollo 的所有操作都從這裡開始，提供了豐富的 API\n_ apollo-cache-inmemory: Apollo 推薦的 Cache\n_ apollo-link-http: Apollo 用來和 Server 端通訊\n_ apollo-link-error: Apollo Client 錯誤處理\n_ apollo-link-state: 本地狀態管理\n_ graphql-tag: 提供 gql 方法，方便定義 queries 和 mutations</li>\n</ul>\n</li>\n<li><code>npm install graphql</code> 解析 GraphQL queries</li>\n<li><del>react-apollo: 連線 Apollo 和 React 的 UI 元件</del></li>\n</ul>\n<p>目前練習覺得 react hooks 要 graphql 需要的有\n<code>npm install @apollo/react-hooks graphql-tag apollo-client apollo-cache-inmemory</code>\n看 graphql server 情形 <code>npm install apollo-link-http apollo-link-context</code></p>\n<h2>Reference</h2>\n<ul>\n<li>範例程式 Youtube <a href=\"https://www.youtube.com/channel/UC2-slOJImuSc20Drbf88qvg/playlists\" target=\"_blank\" rel=\"nofollow\">Classed</a> 教學</li>\n<li><a href=\"https://blog.apollographql.com/apollo-client-now-with-react-hooks-676d116eeae2\" target=\"_blank\" rel=\"nofollow\">Apollo Client, now with React Hooks</a></li>\n<li>iT 邦幫忙 <a href=\"https://juejin.im/post/5b5545a0e51d4518e3119933\" target=\"_blank\" rel=\"nofollow\">graphQL 基礎實踐</a></li>\n<li><a href=\"https://ithelp.ithome.com.tw/articles/10209136\" target=\"_blank\" rel=\"nofollow\">Think in GraphQL</a></li>\n<li>\n<p>Modern Web 共筆</p>\n<ul>\n<li><a href=\"https://hackmd.io/@ModernWeb/2019/%2F%40ModernWeb%2FHJOmKQFNr\" target=\"_blank\" rel=\"nofollow\">在 iCHEF 以 Apollo + React 導入 GraphQL 的經驗 - 張登皓</a></li>\n<li><a href=\"https://hackmd.io/@ModernWeb/2019/%2F%40ModernWeb%2FBkf-KXFNH\" target=\"_blank\" rel=\"nofollow\">GraphQL Best Practice - 曾建勳 (kpman)</a></li>\n</ul>\n</li>\n<li>\n<p>Server-side rendering - <a href=\"https://medium.com/rytass/how-to-combine-client-side-rendering-with-server-side-rendering-by-using-graphql-apollo-e36be1f46713\" target=\"_blank\" rel=\"nofollow\">How to combine Client Side Rendering with Server Side Rendering by using GraphQL (Apollo)</a></p>\n<ul>\n<li>可使用 <code>getDataFromTree</code> and <code>renderToStringWithData</code> SSR functions 來減少沒用 SSR 的 bundle sizes</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li>\n<p>為何不熱門：</p>\n<ul>\n<li>必須要在服務端搭建符合 GraphQL spec 的接口，改寫服務端暴露數據的方式</li>\n<li>用 Node + React 架構外，引入 GraphQL 成本略高，風險也不小</li>\n<li>數據庫查詢可能會成為性能瓶頸</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2>Modern Web 共筆</h2>\n<p><a href=\"https://modernweb.tw/agenda.html\" target=\"_blank\" rel=\"nofollow\">https://modernweb.tw/agenda.html</a>\n<a href=\"https://hackmd.io/@ModernWeb/2019/%2F71piZu48R_CLqXaDx9-pNw\" target=\"_blank\" rel=\"nofollow\">https://hackmd.io/@ModernWeb/2019/%2F71piZu48R_CLqXaDx9-pNw</a></p>","timeToRead":9,"frontmatter":{"title":"GraphQL & Apollo Client","date":"07 Sep 2019","tags":["apollo"],"path":"blog/20190907","excerpt":"簡單介紹 React Client 端如何用 Apollo 對 GraphQL Server 做資料存取操作。"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"blog/20210110","title":"Pop Quiz","tags":["javascript"],"excerpt":"記錄踩到的陷阱題。"}}},{"node":{"frontmatter":{"path":"blog/20210109-3","title":"REST / RESTful & HTTP Methods","tags":["javascript"],"excerpt":"簡易整理。"}}},{"node":{"frontmatter":{"path":"blog/20191107","title":"Javascript Event loop - macro task & micro task","tags":["javascript"],"excerpt":"介紹 Event loop 容易混淆的異步任務 macro task & micro task。"}}},{"node":{"frontmatter":{"path":"blog/20190906","title":"初探 Storybook","tags":["javascript"],"excerpt":"初探這款能夠在開發前端元件或是函式庫的同時，可以快速地建立元件各種操作模式或是樣式的工具。"}}},{"node":{"frontmatter":{"path":"blog/20190707","title":"JavaScript HTML5 Web Worker & CRA 使用踩雷","tags":["javascript"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20190108","title":"JavaScript 認識非同步 Callback, Promise, async/await","tags":["javascript"],"excerpt":"Asynchronous 非同步的不同寫法的整理筆記。"}}},{"node":{"frontmatter":{"path":"blog/20180514","title":"JavaScript 中 this 指向","tags":["javascript"],"excerpt":"簡介 this 指向的六種情況。"}}},{"node":{"frontmatter":{"path":"blog/20180521","title":"Web 常見攻擊手法","tags":["security"],"excerpt":"擁有基本的資安觀念保護好自家資料和 user 使用環境是開發人員重要的一點。"}}},{"node":{"frontmatter":{"path":"blog/20170728","title":"WebForm 註冊 JavaScript","tags":["asp.net","javascript"],"excerpt":"動態產生JS在目前公司專案中是滿常用到的小技巧，不同的用法會產生在Web Page 的不同位置而有直譯式語言的前後順序差。"}}},{"node":{"frontmatter":{"path":"blog/20170714","title":"WebForm 使用 reCAPTCHA 驗證","tags":["asp.net"],"excerpt":"這個我不是機器人驗證一定不陌生，滿多登入畫面會看到的，剛好今天接到把圖形驗證改為 reCAPTCHA 就順手記下。"}}},{"node":{"frontmatter":{"path":"blog/20170604","title":"Web App 推播通知","tags":["asp.net"],"excerpt":"隨著行動和穿載裝置的興起，推播通知 (Push Notification) 成為維繫App用戶關係相當有力的工具"}}},{"node":{"frontmatter":{"path":"blog/20170508","title":"WebForm 圖片上傳檢查","tags":["asp.net"],"excerpt":"開放上傳有可能被傳奇怪東西的風險，只檢查所看到的副檔名，謹慎來說似乎是不夠的。"}}},{"node":{"frontmatter":{"path":"blog/20170421","title":"存取遠端 EventLog","tags":["asp.net","javascript"],"excerpt":"在公司中實作一個 Event log 的查詢工具。（之後來寫了 D3 呈現查詢異常查詢的部分）"}}},{"node":{"frontmatter":{"path":"blog/20210109","title":"Response Set-Cookie 無效","tags":["apollo"],"excerpt":"記錄個之前在和同事們弄 Side project 時犯蠢遇到的問題與解決方式。"}}},{"node":{"frontmatter":{"path":"blog/20191125","title":"初探 RxJS（下）","tags":["rxjs"],"excerpt":"簡介上次未完的 RxJS 剩餘角色，和介紹目前公司後台專案使用的 redux-observable。"}}},{"node":{"frontmatter":{"path":"blog/20200518","title":"常用 NoSQL 雲端資料庫 - Part 1 MongoDB","tags":["mongodb"],"excerpt":"簡介 Relational/NoSQL database、mongoose ORM 寫 mongo CRUD API。"}}},{"node":{"frontmatter":{"path":"blog/20190906-2","title":"React Hooks - useCallback, useMemo, useRef","tags":["reactjs"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20210109-2","title":"IntersectionObserver","tags":["javascript"],"excerpt":"公司專案有個日期連動的 scroll 優化試驗，原先是監聽 scroll。"}}},{"node":{"frontmatter":{"path":"blog/20200910","title":"Apollo Server 入門篇","tags":["apollo"],"excerpt":"快速複習去年分享的 GraphQL Schema 和 Client query 語法，並簡介如何以 Apollo Server 建立 GraphQL Server。"}}},{"node":{"frontmatter":{"path":"blog/20200630","title":"Express - Authentication, Authorization and Security","tags":["security","express"],"excerpt":"簡介 Express RESTful API Server 範例中 JWT 權限、授權相關。"}}},{"node":{"frontmatter":{"path":"blog/20200527","title":"常用 NoSQL 雲端資料庫 - Part 2 Firebase","tags":["firebase"],"excerpt":"簡介 Google 提供的後端服務平臺（BaaS）中的兩種 DB，realtime database 和 cloud firestore。"}}},{"node":{"frontmatter":{"path":"blog/20191017","title":"初探 RxJS（上）","tags":["rxjs"],"excerpt":"簡介相關的設計模式中的 Behavioral Pattern，再介紹 RxJS（先講 Observable）"}}},{"node":{"frontmatter":{"path":"blog/20190909","title":"Prisma - Schema, Data Model, Relations, Client","tags":["prisma"],"excerpt":"未來 Side project 可能會應用到的 SDL first 開發流程角度，簡介此可以取代傳統 ORM 的 DB toolkit。"}}}]}},"pageContext":{"postPath":"blog/20190907","translations":[{"hreflang":"en","path":"/blog/20190907"}]}},"staticQueryHashes":["4097791827"]}