{"componentChunkName":"component---src-templates-post-post-jsx","path":"/blog/20210109-2","result":{"data":{"markdownRemark":{"html":"<p>IntersectionObserver API 提供一種可以異步監聽目標元素與根元素視口 viewport 交叉狀態的手段<br>\n→ 讓你知道哪時觀察的目標元素進入或離開 viewport<br>\n→ 可以觀察一個目標元素是否在 viewport 內<br>\n→ 自動觀察元素是否可見，像商店的歡迎光臨自動門<br>\n<img src=\"https://i.imgur.com/C50gpNY.png%20=400x\"></p>\n<div class=\"warning\">\n傳統實現方法是：監聽 scroll 事件，調用目標元素 getBoundingClientRect() 方法得到它對應於 viewport 左上角的坐標，再判斷是否在 viewport 內。\n缺點是由於 scroll 事件密集發生，計算量很大，容易造成性能問題。\n</div>\n<h2>建立 IntersectionObserver</h2>\n<ol>\n<li>\n<p>建立觀察器（observer）</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">const observer = new IntersectionObserver(callback, [option]); // 瀏覽器原生提供的構造函數</code>\n        </deckgo-highlight-code>\n<ul>\n<li><code>callback</code>：當目標可見性變化時的回調函數</li>\n<li>\n<p><code>option</code>：觀察器配置項（optional），default 如下</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">{\nroot: null,\nrootMargin: &quot;0px 0px 0px 0px&quot;,\nthreshold: [0],\n// V2 新增：\ndelay: 0,\ntrackVisibility: false,\n}</code>\n        </deckgo-highlight-code>\n<p><strong>參數說明</strong></p>\n</li>\n<li><code>root</code>：\nDOM element，指定目標元素所在的容器節點（即根元素）。null 時指的是 window，表示可被觀察的區域 viewport。當目標物進入或離開 root 時會觸發 callback。目標元素必須在 root 元素內。</li>\n<li><code>rootMargin</code>：\n跟 CSS 一樣上右下左順序，定義根元素的 margin，用來擴展或縮小 rootBounds 矩形的大小，從而影響 intersectionRect 交叉區域的大小。\n<img src=\"https://i.imgur.com/tR6F4EH.png\"></li>\n<li><code>threshold</code>：\n目標與 viewport 的交叉比例，單值或 Array，0~1 值，決定什麼時候觸發回調函數。\n<a href=\"https://developers.google.com/web/updates/images/2016/04/intersectionobserver/threshold.gif\" target=\"_blank\" rel=\"nofollow\">看 <code>threshold: [0, 0.25, 0.5, 0.75, 1]</code> 圖例</a>，代表當綠色方塊出現了 0%、25%、50%、75%、100% 這些範圍後，都會執行一次 callback</li>\n<li><code>delay</code>：\n指定監測到目標元素變更後延遲多久才觸發回調函數</li>\n<li><code>trackVisibility</code>：\n表示是否需要監測目標元素在可視區是否可見</li>\n</ul>\n</li>\n<li>\n<p>指定觀察器 observer 要觀察的目標 element（可以觀察多個）</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">observer.observe(element); // 不用再觀察時記得 unobserve 取消\n// observer.observe(element2)\n// observer.observe(element3)</code>\n        </deckgo-highlight-code>\n<p>停止觀察目標</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">observer.unobserve(element);</code>\n        </deckgo-highlight-code>\n<p>停止觀察器</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">observer.disconnect();</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p><code>callback</code> 函數的參數 entries 是 IntersectionObserverEntry Array，如果同時有兩個被觀察的對象的可見性發生變化，entries 數組就會有兩個成員\n<code>IntersectionObserverEntry</code> 提供目標元素的信息</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">let callback = (entries, observer) =&gt; {\n entries.forEach((entry) =&gt; {\n   // Each entry describes an intersection change for one observed\n   // target element:\n   //   entry.boundingClientRect    目標元素的矩形區域的信息\n   //   entry.intersectionRatio    目標元素的可見比例 [註1]\n   //   entry.intersectionRect    目標元素與 viewport 的交叉區域的信息\n   //   entry.isIntersecting    目標元素當前是否可見（boolean）\n   //   entry.rootBounds    根元素的矩形區域的信息，getBoundingClientRect()方法的返回值\n   //   entry.target    被觀察的目標 DOM 對象\n   //   entry.time    可見性發生變化的時間（ms）\n   //   entry.isVisible V2 提供的新屬性，目標元素在可視區是否可見（有無被其他元素遮擋）（boolean）\n });\n};</code>\n        </deckgo-highlight-code>\n<ul>\n<li>註 1. <code>intersectionRatio</code>：0~1 值，即 intersectionRect 佔 boundingClientRect 的比例，完全可見時為 1，完全不可見時等於 0\n<img src=\"https://i.imgur.com/jCoCIYB.png%20=400x\"><br>\n<a href=\"https://codesandbox.io/s/04vvrxj79p\" target=\"_blank\" rel=\"nofollow\">參考很視覺化的範例，React custom hook useIntersect 寫法</a><br>\n<img src=\"https://i.imgur.com/OuSJJk2.png\"><br>\n<img src=\"https://i.imgur.com/f0ns8Zy.png\"></li>\n</ul>\n</li>\n</ol>\n<div class=\"warning\">\n注意：\n<ol>\n<li>不用繼續觀察的對象記得取消觀察</li>\n<li>Callback 在 main thread 執行，當中的操作應該要盡可能的輕量快速，若是耗時操作請自行參考<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\" target=\"_blank\" rel=\"nofollow\">Window.requestIdleCallback()</a></li>\n<li>\n<p>規格寫明 IntersectionObserver 的實現，應該採用 requestIdleCallback()，即只有線程空閒下來，才會執行觀察器。這個觀察器的優先級非常低，只在其他任務執行完，瀏覽器有了空閒才會執行。</p>\n</div>\n</li>\n</ol>\n<h2>常見使用情境</h2>\n<ul>\n<li>Lazy load</li>\n<li>無限滾動</li>\n<li>當元素出現在／離開可視範圍內動畫</li>\n<li>側邊欄固定</li>\n<li>\n<p>計算廣告在頁面上曝光的次數、時間</p>\n<ul>\n<li>自行參考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API/Timing_element_visibility\" target=\"_blank\" rel=\"nofollow\">Timing element visibility with the Intersection Observer API</a></li>\n<li><a href=\"https://letswritetw.github.io/letswrite-intersection-observer/\" target=\"_blank\" rel=\"nofollow\">https://letswritetw.github.io/letswrite-intersection-observer/</a></li>\n</ul>\n</li>\n</ul>\n<h2>Can I Use</h2>\n<p><a href=\"https://caniuse.com/mdn-api_intersectionobserver\" target=\"_blank\" rel=\"nofollow\"><img src=\"https://i.imgur.com/9uQG3uR.jpg\"></a>\n支援度在 IE 直接 GG，視支援度需求記得加 <a href=\"https://github.com/w3c/IntersectionObserver/tree/master/polyfill#browser-support\" target=\"_blank\" rel=\"nofollow\">polyfill</a></p>\n<h2>References</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API/Timing_element_visibility\" target=\"_blank\" rel=\"nofollow\">MDN Web docs - Intersection Observer API</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html\" target=\"_blank\" rel=\"nofollow\">阮一峰 - IntersectionObserver API 使用教程</a></li>\n<li><a href=\"https://developers.google.com/web/updates/2016/04/intersectionobserver\" target=\"_blank\" rel=\"nofollow\">Surma - IntersectionObserver’s Coming into View</a> (2016/4)</li>\n<li><a href=\"https://developers.google.com/web/updates/2017/09/sticky-headers\" target=\"_blank\" rel=\"nofollow\">Eric Bidelman - An event for CSS position:sticky</a> (2017/9)</li>\n<li><a href=\"https://medium.com/the-non-traditional-developer/how-to-use-an-intersectionobserver-in-a-react-hook-9fb061ac6cb5\" target=\"_blank\" rel=\"nofollow\">How To Use an IntersectionObserver in a React Hook</a> 假設只觀察一個 node 可看</li>\n<li><a href=\"https://letswritetw.github.io/letswrite-intersection-observer/\" target=\"_blank\" rel=\"nofollow\">Augustus - IntersectionObserver：下篇-實際應用\nlazyload、進場效果、無限捲動</a></li>\n</ul>","timeToRead":4,"frontmatter":{"title":"IntersectionObserver","date":"09 Jan 2021","tags":["javascript"],"path":"blog/20210109-2","excerpt":"公司專案有個日期連動的 scroll 優化試驗，原先是監聽 scroll。"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"blog/20210110","title":"Pop Quiz","tags":["javascript"],"excerpt":"記錄踩到的陷阱題。"}}},{"node":{"frontmatter":{"path":"blog/20210109","title":"Response Set-Cookie 無效","tags":["apollo"],"excerpt":"記錄個之前在和同事們弄 Side project 時犯蠢遇到的問題與解決方式。"}}},{"node":{"frontmatter":{"path":"blog/20210109-3","title":"REST / RESTful & HTTP Methods","tags":["javascript"],"excerpt":"簡易整理。"}}},{"node":{"frontmatter":{"path":"blog/20200910","title":"Apollo Server 入門篇","tags":["apollo"],"excerpt":"快速複習去年分享的 GraphQL Schema 和 Client query 語法，並簡介如何以 Apollo Server 建立 GraphQL Server。"}}},{"node":{"frontmatter":{"path":"blog/20200630","title":"Express - Authentication, Authorization and Security","tags":["security","express"],"excerpt":"簡介 Express RESTful API Server 範例中 JWT 權限、授權相關。"}}},{"node":{"frontmatter":{"path":"blog/20190909","title":"Prisma - Schema, Data Model, Relations, Client","tags":["prisma"],"excerpt":"未來 Side project 可能會應用到的 SDL first 開發流程角度，簡介此可以取代傳統 ORM 的 DB toolkit。"}}},{"node":{"frontmatter":{"path":"blog/20200527","title":"常用 NoSQL 雲端資料庫 - Part 2 Firebase","tags":["firebase"],"excerpt":"簡介 Google 提供的後端服務平臺（BaaS）中的兩種 DB，realtime database 和 cloud firestore。"}}},{"node":{"frontmatter":{"path":"blog/20200518","title":"常用 NoSQL 雲端資料庫 - Part 1 MongoDB","tags":["mongodb"],"excerpt":"簡介 Relational/NoSQL database、mongoose ORM 寫 mongo CRUD API。"}}},{"node":{"frontmatter":{"path":"blog/20191125","title":"初探 RxJS（下）","tags":["rxjs"],"excerpt":"簡介上次未完的 RxJS 剩餘角色，和介紹目前公司後台專案使用的 redux-observable。"}}},{"node":{"frontmatter":{"path":"blog/20190906","title":"初探 Storybook","tags":["javascript"],"excerpt":"初探這款能夠在開發前端元件或是函式庫的同時，可以快速地建立元件各種操作模式或是樣式的工具。"}}},{"node":{"frontmatter":{"path":"blog/20191017","title":"初探 RxJS（上）","tags":["rxjs"],"excerpt":"簡介相關的設計模式中的 Behavioral Pattern，再介紹 RxJS（先講 Observable）"}}},{"node":{"frontmatter":{"path":"blog/20190907","title":"GraphQL & Apollo Client","tags":["apollo"],"excerpt":"簡單介紹 React Client 端如何用 Apollo 對 GraphQL Server 做資料存取操作。"}}},{"node":{"frontmatter":{"path":"blog/20190707","title":"JavaScript HTML5 Web Worker & CRA 使用踩雷","tags":["javascript"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20191107","title":"Javascript Event loop - macro task & micro task","tags":["javascript"],"excerpt":"介紹 Event loop 容易混淆的異步任務 macro task & micro task。"}}},{"node":{"frontmatter":{"path":"blog/20180514","title":"JavaScript 中 this 指向","tags":["javascript"],"excerpt":"簡介 this 指向的六種情況。"}}},{"node":{"frontmatter":{"path":"blog/20180521","title":"Web 常見攻擊手法","tags":["security"],"excerpt":"擁有基本的資安觀念保護好自家資料和 user 使用環境是開發人員重要的一點。"}}},{"node":{"frontmatter":{"path":"blog/20170714","title":"WebForm 使用 reCAPTCHA 驗證","tags":["asp.net"],"excerpt":"這個我不是機器人驗證一定不陌生，滿多登入畫面會看到的，剛好今天接到把圖形驗證改為 reCAPTCHA 就順手記下。"}}},{"node":{"frontmatter":{"path":"blog/20170604","title":"Web App 推播通知","tags":["asp.net"],"excerpt":"隨著行動和穿載裝置的興起，推播通知 (Push Notification) 成為維繫App用戶關係相當有力的工具"}}},{"node":{"frontmatter":{"path":"blog/20190108","title":"JavaScript 認識非同步 Callback, Promise, async/await","tags":["javascript"],"excerpt":"Asynchronous 非同步的不同寫法的整理筆記。"}}},{"node":{"frontmatter":{"path":"blog/20170728","title":"WebForm 註冊 JavaScript","tags":["asp.net","javascript"],"excerpt":"動態產生JS在目前公司專案中是滿常用到的小技巧，不同的用法會產生在Web Page 的不同位置而有直譯式語言的前後順序差。"}}},{"node":{"frontmatter":{"path":"blog/20170508","title":"WebForm 圖片上傳檢查","tags":["asp.net"],"excerpt":"開放上傳有可能被傳奇怪東西的風險，只檢查所看到的副檔名，謹慎來說似乎是不夠的。"}}},{"node":{"frontmatter":{"path":"blog/20190906-2","title":"React Hooks - useCallback, useMemo, useRef","tags":["reactjs"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20170421","title":"存取遠端 EventLog","tags":["asp.net","javascript"],"excerpt":"在公司中實作一個 Event log 的查詢工具。（之後來寫了 D3 呈現查詢異常查詢的部分）"}}}]}},"pageContext":{"postPath":"blog/20210109-2","translations":[{"hreflang":"en","path":"/blog/20210109-2"}]}},"staticQueryHashes":["4097791827"]}