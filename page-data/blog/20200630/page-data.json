{"componentChunkName":"component---src-templates-post-post-jsx","path":"/blog/20200630","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://hackmd.io/AiLYT8n8TRq5H8ln52b27g?view\" target=\"_blank\" rel=\"nofollow\">HackMD</a></p>\n<p>簡介 Express RESTful API Server 範例中 (使用 MongoDB ODM Mongoose)</p>\n<ul>\n<li>利用 JWT 做驗證 (Authentication)</li>\n<li>利用自己定義的 User roles 和 permissions 做授權 (Authorization)</li>\n<li>利用一些現行可防止常見的安全性問題的 middleware、密碼做處理 (Security)</li>\n</ul>\n<p><a href=\"https://gitlab.baifu-tech.net/f2e_tw/hr-api-server\" target=\"_blank\" rel=\"nofollow\">👉 GitLab Clone</a></p>\n<h2><a href=\"https://jwt.io/\" target=\"_blank\" rel=\"nofollow\">JSON Web Token (JWT)</a> 簡介</h2>\n<blockquote>\n<p>有限時間內可利用認證令牌要求對應的 API 操作權限</p>\n</blockquote>\n<ul>\n<li>基於 JSON Object 的開放標準協議 <a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"nofollow\">RFC 7519</a></li>\n<li>\n<p>適用於授權和訊息交換</p>\n<ul>\n<li>單一登錄 (Single Sign On) 是當今廣泛使用 JWT 的功能之一，成本較小且可以在不同的 domain 中輕鬆使用</li>\n</ul>\n</li>\n<li>\n<p>符合 Stateless 無狀態 (payload 中直接給 Server 需要的值，JWT 應能表明身份)</p>\n<ul>\n<li>易水平擴展，適用於跨伺服器、跨域的請求</li>\n</ul>\n</li>\n<li>\n<p>Token 應只能在 Server 端被驗證，並 <strong>store JWT in HTTPOnly cookies</strong></p>\n<ul>\n<li>Cookie 只限被伺服端存取，無法在用戶端讀取</li>\n<li>抵禦攻擊者利用 Cross-Site Scripting (XSS) 手法來盜取用戶身份，例如 <code>document.cookie</code> 取得 cookies</li>\n<li>Chrome 有像 <a href=\"https://chrome.google.com/webstore/detail/editthiscookie/fngmhnnpilhplaeedifhccceomclgfbg\" target=\"_blank\" rel=\"nofollow\">EditThisCookie</a> 的查看/修改 Cookie 工具</li>\n</ul>\n</li>\n<li>適用於無關安全議題的操作權限授與</li>\n<li>\n<p>無法取代 Cookies 或 Session，只是一種新的操作權限的授與方法</p>\n<ul>\n<li>Session、Cookie、JWT 是可以一起使用的</li>\n</ul>\n</li>\n<li>可以做為實現 <strong>OAuth 2.0 授權框架規範</strong> <a href=\"https://tools.ietf.org/html/rfc6749\" target=\"_blank\" rel=\"nofollow\">RFC 6749</a> 中的一種認證機制使用</li>\n</ul>\n<h3>JWT 組成 (這邊都指 JWS Compact Serialization)</h3>\n<blockquote>\n<p><a href=\"https://tools.ietf.org/html/rfc7515\" target=\"_blank\" rel=\"nofollow\">JWS(JSON Web Signature)</a> 和 <a href=\"https://tools.ietf.org/html/rfc7516\" target=\"_blank\" rel=\"nofollow\">JWE(JSON Web Encryption)</a> 是 JWT 的實作方式，這邊簡介和實作範例都是 JWS (Compact Serialization)：小、自包含、最簡易 👻</p>\n</blockquote>\n<p><img src=\"https://i.imgur.com/8ny9Nla.png\"><br>\n<img src=\"https://i.imgur.com/MbEmWgj.png\"><br>\nJWT 由 header、payload、signature 三個部分各自 base64 編碼處理後組成</p>\n<ul>\n<li>\n<p>header：伺服器如何加解密的依據</p>\n<deckgo-highlight-code json  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">{\n&quot;alg&quot;: &quot;HS256&quot;, // ALGORITHM: required\n&quot;typ&quot;: &quot;JWT&quot; // TOKEN TYPE: optional\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>payload (claims)：放認證需要的聲明內容</p>\n<deckgo-highlight-code json  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">{\n&quot;sub&quot;: &quot;1234567890&quot;,\n&quot;name&quot;: &quot;John Doe&quot;,\n&quot;iat&quot;: 1516239022\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>Reserved (註冊聲明) - 建議但不強制使用</li>\n<li>iss (issuer)：發行人</li>\n<li>sub (subject)：主題 (用戶)</li>\n<li>\n<p>aud (audience)：目標收件人</p>\n<ul>\n<li>通常為 URI 清單，表示此 JWT 可存取該清單中的資源 (位址)</li>\n</ul>\n</li>\n<li>exp (expiration time)：到期的時間</li>\n<li>nbf (not before time)：開始有效的時間</li>\n<li>iat (issued at time)：發布時間</li>\n<li>jti (JWT ID)</li>\n<li>Public (公開聲明) - <a href=\"https://www.iana.org/assignments/jwt/jwt.xhtml#claims\" target=\"_blank\" rel=\"nofollow\">IANA JSON Web Token</a> 聲明註冊表上註冊的聲明</li>\n<li>Private (私有聲明) - 自定義的臨時聲明</li>\n</ul>\n</li>\n<li>\n<p>Verify Signature：登入時伺服器端找到吻合的帳戶密碼，就產生一個認證簽名</p>\n<ul>\n<li>可以比對 Signature 來確認 data 有無被改動</li>\n</ul>\n</li>\n<li>通常會產 Access Token 和 Refresh Token 兩種 Token (此次介紹屬於 Access Token)</li>\n<li>\n<p>稍微提一下</p>\n<ul>\n<li>header 又稱 JOSE Header (JSON Object Signing and Encryption)，<a href=\"https://tools.ietf.org/html/rfc7518#section-3.1\" target=\"_blank\" rel=\"nofollow\">JWE</a> 和 <a href=\"https://tools.ietf.org/html/rfc7518#section-4.1\" target=\"_blank\" rel=\"nofollow\">JWS</a> 適用的 alg 不相同</li>\n<li>JWE token 不同於分三段的 JWS，JWE 是分成五段：JOSE Header、Encrypted Key、Initialization Vector(IV)、AAD、Ciphertext、Authentication Tag</li>\n<li>其中 JOSE Header 是三種 Header 聯集而成：<br>\nProtected Header + Shared Unprotected Header + Per-Recipient Unprotected Header</li>\n</ul>\n</li>\n</ul>\n<h3>產生 JWS 流程</h3>\n<p>header 和 payload 是可以自行輕易 decode 的 (或直接貼<a href=\"https://jwt.io/\" target=\"_blank\" rel=\"nofollow\">官網</a>解) ，不應放任何敏感資訊</p>\n<ol>\n<li>\n<p>讀取 header 中的加密演算法 (<code>alg</code>: 必要) 例如 HMAC、SHA256、RSA、none</p>\n<ul>\n<li>列消息認證碼 Hash-based Message Authentication Code (HMAC)<br>\n一種金鑰式雜湊演算法，可以結合加密金鑰 (key) 進行加密最後輸出 64 字元的內容，針對各種哈希算法都通用 (MD5, SHA-1, SHA-256...)</li>\n<li>HS256 (HMAC with SHA-256)</li>\n<li><code>alg: none</code> 時 JWT 將不用產生 Signature，就有機會被攻擊來繞過 Token 的來源驗證</li>\n</ul>\n</li>\n<li>建立尚未簽名的令牌<br>\n將 header 與 payload 各自進行 base64 編碼並且以<code>.</code>連結得到</li>\n<li>取得簽名令牌 signature<br>\n利用私鑰 key 對尚未簽名的令牌進行加密簽名得到<br>\n⚠️ 絕對要保管好 key，不然誰都可以自行產生 JWT</li>\n<li>將 2. 與 base64 編碼後的 3. 結果以<code>.</code>連結，即為 JWT token<br>\n<img src=\"https://i.imgur.com/oMQboKh.png\"></li>\n</ol>\n<h3>實作：Express app 中可以透過 <a href=\"https://www.npmjs.com/package/jsonwebtoken\" target=\"_blank\" rel=\"nofollow\"><code>jsonwebtoken</code></a> 產生及驗證 JWT(JWS)</h3>\n<ul>\n<li><code>npm i jsonwebtoken</code></li>\n<li>\n<p>簽發 token<br>\n時機：通常會在使用者註冊、登入、更新密碼時產生或更新 JWT Token 來做身份認證 (ps. 用戶被移除時也該讓 Token 失效)<br>\n<code>jwt.sign(payload, secretOrPrivateKey, [options, callback])</code></p>\n<ul>\n<li>options 的 algorithm 預設為 HS256</li>\n<li>Ex. 簽發一個一小時後過期的 JWT token (多種寫法沒有一定)</li>\n</ul>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">import jwt from &#39;jsonwebtoken&#39;;\n\n// 1.\njwt.sign(\n  {\n    exp: Math.floor(Date.now() / 1000) + 60 * 60,\n    data: &#39;foobar&#39;,\n  },\n  &#39;secret&#39;\n);\n\n// 2.\njwt.sign(\n  {\n    data: &#39;foobar&#39;,\n  },\n  &#39;secret&#39;,\n  { expiresIn: 60 * 60 }\n);\n\n// 3. 最好懂 👍\njwt.sign(\n  {\n    data: &#39;foobar&#39;,\n  },\n  &#39;secret&#39;,\n  { expiresIn: &#39;1h&#39; }\n);</code>\n        </deckgo-highlight-code>\n<p>實際可能封裝成像 signToken function 每次簽發時使用</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">import jwt from &#39;jsonwebtoken&#39;;\n\nconst signToken = (id) =&gt; {\n  return jwt.sign({ id }, process.env.JWT_SECRET, {\n    expiresIn: process.env.JWT_EXPIRES_IN,\n  });\n};</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>認證 Token<br>\n若伺服器端在請求中沒有找到 Token，回傳錯誤 (401 Unauthorized)；若有找到 Token 則驗證後再執行操作\n<code>jwt.verify(token, secretOrPublicKey, [options, callback])</code></p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">import { promisify } from &#39;util&#39;;\nimport jwt from &#39;jsonwebtoken&#39;;\n// ...\nconst decoded = await jwt.verify(token, process.env.JWT_SECRET);\n// decoded.id</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code json  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">// decoded\n{ &quot;id&quot;: &quot;5ee38288007f218942c9bd1b&quot;, &quot;iat&quot;: 1592380082, &quot;exp&quot;: 1600156082 }</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>只認令牌不認人，只能<strong>盡量</strong>確保 key 不會被盜取</p>\n<ul>\n<li>最好不要將 token 存在 localStorage (容易被 XSS 攻擊竊取)</li>\n<li>只在 HTTPS 安全協定下傳遞</li>\n<li>Cookie 設定 flag <code>httpOnly</code> (無法被 JavaScript 存取), <code>secure</code> (只在 HTTPS 傳遞)</li>\n<li>設置 token 過期時間... etc.</li>\n<li>Ex. 如註冊和登入時去產生新的 JWT token 並透過盡量安全的方式送給 client (client 獲得令牌獲得授權)</li>\n<li>\n<p>Client 之後再將此令牌 (JWT) 設置在 Header Authorization 去要求 API，Server 再依此做認證，成功的話返回資料</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">const createSendToken = (user, statusCode, res) =&gt; {\nconst token = signToken(user._id);\nconst cookieOptions = {\n  expires: new Date(Date.now() + process.env.JWT_COOKIE_EXPIRES_IN * 24 * 60 * 60 * 1000),\n  httpOnly: true, // cookie 無法用 JavaScript 讀取但仍可以在 HTTP requests 回傳給 server\n};\n\nif (process.env.NODE_ENV === &#39;production&#39;) cookieOptions.secure = true; // 限 HTTPS\n\nres.cookie(&#39;jwt&#39;, token, cookieOptions);\n\ndelete user.password;\n\nres.status(statusCode).json({\n  status: &#39;success&#39;,\n  token,\n  data: {\n    user,\n  },\n});\n};</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>在某些需授權(認證通過)才能操作的 API route 前加一層 Middleware (要 return <code>next()</code>)</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">router.patch(&#39;/updateMe&#39;, authController.protect, userController.updateMe);\nrouter.delete(&#39;/deleteMe&#39;, authController.protect, userController.deleteMe);</code>\n        </deckgo-highlight-code>\n<p>檢查認證：預期 Client 發的 request Headers Authorization 會代上合法 Token &#x26; ...</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">// 需要授權的 API 先經過此做 JWT token 認證 (作為 protected route middleware)\nconst protect = catchAsync(async (req, res, next) =&gt; {\nlet token;\nif (req.headers.authorization &amp;&amp; req.headers.authorization.startsWith(&#39;Bearer&#39;)) {\n  token = req.headers.authorization.split(&#39; &#39;)[1];\n}\n\nif (!token) {\n  return next(new AppError(&#39;認證已失效，請重新登入&#39;, 401));\n}\n\n// 認證 JWT (token key 要正確才過) 取回 payload (可以檢查 JWT 授權者身份或資料有無變造)\nconst decoded = await jwt.verify(token, process.env.JWT_SECRET);\n\nconst currentUser = await User.findById(decoded.id);\nif (!currentUser) {\n  return next(new AppError(&#39;擁有此認證的使用者已不存在&#39;, 401));\n}\n\n// 檢查 token 簽發時間是否在變更密碼時間之後，是的話應重新登入取得新認證\nif (currentUser.changedPasswordAfter(decoded.iat)) {\n  return next(new AppError(&#39;使用者最近變更密碼，請重新登入&#39;, 401));\n}\n\n// 上述檢查沒問題才真正執行 API 查詢操作 (順便傳遞 JWT 的 user)\nreq.user = currentUser;\nnext();\n});</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n</li>\n</ul>\n<h2>密碼做 Bcrypt 加密處理再儲存</h2>\n<ul>\n<li>\n<p>Bcrypt 簡介</p>\n<ul>\n<li>其實不是加密演算法，而是慢雜湊演算法 (和 SHA1 一樣是種雜湊演算法)</li>\n<li>把各個欄位/字元丟進去某個公式計算的方式就叫做雜湊 (Hash)，這個計算公式就稱為雜湊函數 (Hash function)，過程是<strong>不可逆</strong>的</li>\n<li>Bcrypt 可以透過設定疊代次數讓他變慢 (迭代次數每增加 1 需要的時間就變兩倍)</li>\n<li>密碼被破解的風險比 MD5、SHA1 低 (例以疊代五次的 Bcrypt 計算速度大概比 SHA1 慢 1000 倍)</li>\n<li>能夠將一個字串<strong>加鹽後雜湊</strong>加密，在要加密的字串中加特定的字符、打亂原始的字符串，使其生成的散列結果產生變化，加鹽次數多越安全，但加密時間也就越長<br>\n加密後的 bcrypt 分為四個部分<br>\n<img src=\"https://i.imgur.com/Wp3VHdi.png\"></li>\n<li>Bcrypt：該字串為 UTF-8 編碼，並且包含一個終止符</li>\n<li>Round 回合數：每增加一次就加倍雜湊次數，預設 10 次</li>\n<li>Salt 加鹽：128 bits 22 個字元</li>\n<li>Hash 雜湊：138 bits 31 個字元</li>\n<li>防止 rainbow table attacks</li>\n<li>Rainbow table 是一個由大量純文本密碼和與每個密碼相對應的 hash 組成的庫</li>\n<li><a href=\"https://md5hashing.net/\" target=\"_blank\" rel=\"nofollow\">Ultimate Hashing and Anonymity toolkit</a> 可輕易破解長度短簡易的雜湊原文</li>\n</ul>\n</li>\n<li><a href=\"https://www.npmjs.com/package/bcryptjs\" target=\"_blank\" rel=\"nofollow\"><code>npm i bcryptjs</code></a></li>\n<li>\n<p><a href=\"https://www.npmjs.com/package/bcryptjs#hashs-salt-callback-progresscallback\" target=\"_blank\" rel=\"nofollow\"><code>hash(s, salt, callback, progressCallback=)</code></a><br>\n在 mongoose 有 password field 的 Schema 上做 save document 前的 middleware 來處理明文密碼範例</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">userSchema.pre(&#39;save&#39;, async function(next) {\nif (!this.isModified(&#39;password&#39;)) return next(); // 只有在 password 修改時才執行\n\nthis.password = await bcrypt.hash(this.password, 12); // 用長度12的salt去hash\nthis.passwordConfirm = undefined;\nthis.passwordChangedAt = Date.now() - 1000;\nnext();\n});</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>補充一點加密演算法，如：</p>\n<ul>\n<li>對稱加密演算法</li>\n<li>加密解密都用同一個 key，快且安全</li>\n<li>\n<p>例</p>\n<ul>\n<li>AES (Advanced Encryption Standard)</li>\n<li>DES (Data Encryption Standard)、3DES (Triple DES)</li>\n<li>速度：AES > 3DES > DES</li>\n<li>聽說美國政府機密檔案也用 AES 加密(?)</li>\n</ul>\n</li>\n<li>非對稱加密演算法</li>\n<li>會產生一組兩個 Key：公鑰跟私鑰</li>\n<li>私鑰可以產出公鑰、公鑰無法產出私鑰</li>\n<li>兩把鑰匙在加密、解密上彼此可通用：公鑰加密、私鑰解密，或是私鑰加密、公鑰解密 (HTTPS 的 SSL 數位簽章就是此應用)</li>\n<li>例\n_ RSA、DSA (Digital Signature Algorithm)、ECC (Elliptic Curves Cryptography)\n_ 速度：ECC > RSA, DSA\n<img src=\"https://i.imgur.com/m2s3GgW.png\"></li>\n</ul>\n</li>\n</ul>\n<h2>訂定 Role 來限制權限</h2>\n<ul>\n<li>例如 User Model 中的 Schema 定義一 enum 型別的 role，之後依此做權限依據</li>\n<li>\n<p>某些需檢查使用者權限才能操作的 API route，可在操作前加一層檢查 user 權限的 middleware</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">router\n.route(&#39;/:id&#39;)\n.get(tourController.getTour)\n.patch(tourController.updateTour)\n.delete(authController.protect, authController.restrictTo(&#39;admin&#39;, &#39;lead-guide&#39;), tourController.deleteTour);</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">const restrictTo = (...roles) =&gt; {\nreturn (req, res, next) =&gt; {\n  if (!roles.includes(req.user.role)) {\n    return next(new AppError(&#39;您沒有此操作權限&#39;, 403));\n  }\n\n  next();\n};\n};</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h2>一些跟安全性相關的 Middleware library</h2>\n<blockquote>\n<p>Express mongoose restful api 實作用到</p>\n</blockquote>\n<ul>\n<li>\n<p><a href=\"https://www.npmjs.com/package/helmet\" target=\"_blank\" rel=\"nofollow\"><code>npm i helmet</code></a></p>\n<ul>\n<li>A collection of 12 smaller middleware functions that set HTTP response headers.\nExpress app 中的安全最佳做法，會適當設定 HTTP 標頭，有助於防範應用程式出現已知的 Web 漏洞</li>\n<li>\n<p>應放在最一開始設定</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">app.use(helmet());</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://www.npmjs.com/package/express-rate-limit\" target=\"_blank\" rel=\"nofollow\"><code>npm i express-rate-limit</code></a></p>\n<ul>\n<li>限制來自同一 IP 的重複請求</li>\n<li>可防止 DDoS</li>\n</ul>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">import rateLimit from &#39;express-rate-limit&#39;;\n\nconst limiter = rateLimit({\n  max: 100,\n  windowMs: 60 * 60 * 1000,\n  message: &#39;此IP請求太多次了！請一小時後再試！&#39;,\n});\napp.use(&#39;/api&#39;, limiter);</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p><a href=\"https://www.npmjs.com/package/express-mongo-sanitize\" target=\"_blank\" rel=\"nofollow\"><code>npm i express-mongo-sanitize</code></a></p>\n<ul>\n<li>\n<p>Data sanitization 防止 NoSQL query injection，這邊主要針對 MongoDB 的保留字如 <code>$</code>, <code>.</code>。例如在某含有 find email 操作的 api 中 request body 代相當於 query all 的值 <code>{ \"email\": {\"$gt\": \"\"} }</code>，就會被擋下來</p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">app.use(mongoSanitize());</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://www.npmjs.com/package/xss-clean\" target=\"_blank\" rel=\"nofollow\"><code>npm i xss-clean</code></a></p>\n<ul>\n<li>\n<p>Data sanitization 防止 XSS 攻擊，可替換 <code>&#x3C;</code> 為 <code>&#x26;lt;</code></p>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">app.use(xss());</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://www.npmjs.com/package/hpp\" target=\"_blank\" rel=\"nofollow\"><code>npm i hpp</code></a></p>\n<ul>\n<li>用於防止 HTTP Parameter Pollution</li>\n<li>例如網址後面代的 queryString key 相同的不只一個時，它會自動取成最後一個、前面都無效</li>\n<li>但是可以透過把特定 key 加白名單讓它得以不被過濾</li>\n<li>\n<p>應該在最後設定</p>\n<deckgo-highlight-code javascript\\  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">app.use(\nhpp({\nwhitelist: [&#39;age&#39;, &#39;team&#39;]\n});\n);</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n</li>\n</ul>\n<h2>重設密碼機制</h2>\n<p>利用賦予請求重設密碼用戶者 隨機 resetToken 與 Token 過期時間儲存進 DB (同時寄信)，並在更新密碼時實作中用來驗證並透過 Token 查回 User 做更新</p>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/nodemailer\" target=\"_blank\" rel=\"nofollow\"><code>npm i nodemailer</code></a></li>\n<li>開發階段沒有 Mail Server 可以使用 <a href=\"https://mailtrap.io/\" target=\"_blank\" rel=\"nofollow\">MailTrap</a> 測試寄收信<br>\n<img src=\"https://i.imgur.com/yBu0U7l.png\"></li>\n<li>\n<p>利用 Node.js 的內建模組 crypto 來簡單加密處理資料，以下實作範例</p>\n<ol>\n<li>在 Model Schema methods 定義產生密碼重設 Token 並設置過期時間存 DB user 方法：注意是 return 未 Hash 的 Token (要代給修改密碼 API 的 Token)，但儲存的是有在經過 hash 處理後的 Token</li>\n</ol>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">// 透過 node 內建 crypto 安全的亂數產生密碼重設 token，並設置過期時間\nuserSchema.methods.createPasswordResetToken = function() {\n  const resetToken = crypto.randomBytes(32).toString(&#39;hex&#39;);\n\n  this.passwordResetToken = crypto\n    .createHash(&#39;sha256&#39;) // 創建sha256 hash實例\n    .update(resetToken) // update()將字符串相加\n    .digest(&#39;hex&#39;); // digest()將字符串hash返回\n\n  this.passwordResetExpires = Date.now() + 10 * 60 * 1000; // 10 mins 後過期\n\n  return resetToken;\n};</code>\n        </deckgo-highlight-code>\n<ol start=\"2\">\n<li>忘記密碼 API 查詢 email 的 User 存在用對它賦予重設密碼 Token 和過期時間儲存；不存在再清掉重設相關欄位，同時寄出代有該 Token 的重設密碼 API 給 User</li>\n</ol>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">const forgotPassword = catchAsync(async (req, res, next) =&gt; {\n  const user = await User.findOne({ email: req.body.email });\n  if (!user) {\n    return next(new AppError(&#39;查無此 email 使用者&#39;, 404));\n  }\n\n  // 產生 reset 用的隨機 token(Model schema methods 先定義好)\n  const resetToken = user.createPasswordResetToken();\n  await user.save({ validateBeforeSave: false });\n\n  // 設定寄信內容\n  const resetURL = `${req.protocol}://${req.get(&#39;host&#39;)}/api/v1/users/resetPassword/${resetToken}`;\n  const message = `忘記密碼？請用 PATCH 設置 password 和 passwordConfirm 請求 API: ${resetURL}.\\n如果您無忘記密碼，請無視此訊息。`;\n\n  try {\n    await sendEmail({\n      email: user.email,\n      subject: &#39;密碼重設 (10分鐘後過期)&#39;,\n      message,\n    });\n\n    res.status(200).json({\n      status: &#39;success&#39;,\n      message: &#39;重設密碼 Token 已寄出！&#39;,\n    });\n  } catch (err) {\n    user.passwordResetToken = undefined;\n    user.passwordResetExpires = undefined;\n    await user.save({ validateBeforeSave: false });\n\n    return next(new AppError(&#39;寄信發生錯誤！&#39;), 500);\n  }\n});</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">import nodemailer from &#39;nodemailer&#39;;\n\nexport const sendEmail = async (options) =&gt; {\n  // 1) Create a transporter\n  const transporter = nodemailer.createTransport({\n    host: process.env.EMAIL_HOST,\n    port: process.env.EMAIL_PORT,\n    auth: {\n      user: process.env.EMAIL_USERNAME,\n      pass: process.env.EMAIL_PASSWORD,\n    },\n  });\n\n  // 2) Define the email options\n  const mailOptions = {\n    from: &#39;百阜人資系統 &lt;baifu.hr@baifu-tech.net&gt;&#39;,\n    to: options.email,\n    subject: options.subject,\n    text: options.message,\n    // html:\n  };\n\n  // 3) Actually send the email\n  await transporter.sendMail(mailOptions);\n};</code>\n        </deckgo-highlight-code>\n<ol start=\"3\">\n<li>得到重設密碼的 API 驗證 Token 和是否有效後再依 Token 查回 User，對它做密碼更新</li>\n</ol>\n<deckgo-highlight-code javascript  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">const resetPassword = catchAsync(async (req, res, next) =&gt; {\n  // hashed resetToken and compare document&#39;s hashed resetToken passwordResetToken\n  const hashedToken = crypto\n    .createHash(&#39;sha256&#39;)\n    .update(req.params.token)\n    .digest(&#39;hex&#39;);\n\n  const user = await User.findOne({\n    passwordResetToken: hashedToken,\n    passwordResetExpires: { $gt: Date.now() },\n  });\n\n  // 檢查 token 未過期且使用者存在\n  if (!user) {\n    return next(new AppError(&#39;Token 無效或是已過期&#39;, 400));\n  }\n  user.password = req.body.password;\n  user.passwordConfirm = req.body.passwordConfirm;\n  user.passwordResetToken = undefined;\n  user.passwordResetExpires = undefined;\n  await user.save(); // 一樣會經過 middleware 做密碼 hash 並修改 passwordChangedAt\n\n  // 使用者產生新 token 回傳(登入)\n  createSendToken(user, 200, res);\n});</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h2>CSRF</h2>\n<p>因為瀏覽器的機制，你只要發送 request 給某個網域，就會把關聯的 cookie 一起帶上去。如果使用者是登入狀態，那這個 request 就理所當然包含了他的資訊（例如說 session id），這 request 看起來就像是使用者本人發出的。<br>\n又稱 One-Click Attack，但其實甚至不需要 click 而且不會被察覺(沒有 redirect)<br>\n例如</p>\n<deckgo-highlight-code html  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  highlight-lines=\"\">\n          <code slot=\"code\">&lt;iframe style=&quot;display:none&quot; name=&quot;csrf-frame&quot;&gt;&lt;/iframe&gt;\n&lt;form method=&quot;POST&quot; action=&quot;https://small-min.blog.com/delete&quot; target=&quot;csrf-frame&quot; id=&quot;csrf-form&quot;&gt;\n  &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;3&quot; /&gt;\n  &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;\n&lt;/form&gt;\n&lt;script&gt;\n  document.getElementById(&#39;csrf-form&#39;).submit();\n&lt;/script&gt;</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>所以記得每次使用完網站就登出，就可以避免掉 CSRF</p>\n</blockquote>\n<h3>Server 防範</h3>\n<ol>\n<li>檢查 Referer (request 從哪來)，但有的瀏覽器不會帶，或是被關掉</li>\n<li>加上圖形驗證碼、簡訊驗證碼 ...</li>\n<li>產生隨機的 CSRF Token 存在 Server Session，並核對請求者帶的 Session 是否一樣</li>\n<li>Double Submit Cookie：Server 比對 Cookie 內的 CSRF Token 與 form 裡面的 CSRF Token，檢查是否有值並且相等</li>\n</ol>\n<p>下次再補充 JWE (JSON Web Encryption)、 OAuth 2.0 的部分</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://medium.com/@ryanchenkie_40935/react-authentication-how-to-store-jwt-in-a-cookie-346519310e81\" target=\"_blank\" rel=\"nofollow\">React Authentication: How to Store JWT in a Cookie</a></li>\n<li><a href=\"https://medium.com/mr-efacani-teatime/%E6%B7%BA%E8%AB%87jwt%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E8%88%87%E9%81%A9%E7%94%A8%E6%83%85%E5%A2%83-301b5491b60e\" target=\"_blank\" rel=\"nofollow\">淺談 JWT 的安全性與適用情境</a></li>\n<li><a href=\"https://5xruby.tw/posts/what-is-jwt/\" target=\"_blank\" rel=\"nofollow\">是誰在敲打我窗？什麼是 JWT？</a></li>\n<li><a href=\"https://medium.com/starbugs/how-to-store-password-in-database-sefely-6b20f48def92\" target=\"_blank\" rel=\"nofollow\">聽說不能用明文存密碼，那到底該怎麼存？</a></li>\n<li><a href=\"https://kknews.cc/zh-tw/code/kbqp4bb.html\" target=\"_blank\" rel=\"nofollow\">加密算法(DES,AES,RSA,MD5,SHA1,Base64)比較和項目應用</a></li>\n<li><a href=\"http://blog.shaochuancs.com/about-error-capturestacktrace/\" target=\"_blank\" rel=\"nofollow\">關於 Error.captureStackTrace</a></li>\n<li><a href=\"https://mongoosejs.com/docs/api.html\" target=\"_blank\" rel=\"nofollow\">Mongoose API Document</a></li>\n</ul>","timeToRead":15,"frontmatter":{"title":"Express - Authentication, Authorization and Security","date":"30 Jun 2020","tags":["security","express"],"path":"blog/20200630","excerpt":"簡介 Express RESTful API Server 範例中 JWT 權限、授權相關。"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"blog/20210109-3","title":"REST / RESTful & HTTP Methods","tags":["javascript"],"excerpt":"簡易整理。"}}},{"node":{"frontmatter":{"path":"blog/20210110","title":"Pop Quiz","tags":["javascript"],"excerpt":"記錄踩到的陷阱題。"}}},{"node":{"frontmatter":{"path":"blog/20210725","title":"初試 SonarQube","tags":["tool"],"excerpt":"記錄下認識的新東西。"}}},{"node":{"frontmatter":{"path":"blog/20210725-2","title":"SVGR 設置","tags":["javascript"],"excerpt":"webpack loader 以 Component 方式使用 Svg。"}}},{"node":{"frontmatter":{"path":"blog/20200910","title":"Apollo Server 入門篇","tags":["apollo"],"excerpt":"快速複習去年分享的 GraphQL Schema 和 Client query 語法，並簡介如何以 Apollo Server 建立 GraphQL Server。"}}},{"node":{"frontmatter":{"path":"blog/20200527","title":"常用 NoSQL 雲端資料庫 - Part 2 Firebase","tags":["firebase"],"excerpt":"簡介 Google 提供的後端服務平臺（BaaS）中的兩種 DB，realtime database 和 cloud firestore。"}}},{"node":{"frontmatter":{"path":"blog/20210109-2","title":"IntersectionObserver","tags":["javascript"],"excerpt":"公司專案有個日期連動的 scroll 優化試驗，原先是監聽 scroll。"}}},{"node":{"frontmatter":{"path":"blog/20210109","title":"Response Set-Cookie 無效","tags":["apollo"],"excerpt":"記錄個之前在和同事們弄 Side project 時犯蠢遇到的問題與解決方式。"}}},{"node":{"frontmatter":{"path":"blog/20190909","title":"Prisma - Schema, Data Model, Relations, Client","tags":["prisma"],"excerpt":"未來 Side project 可能會應用到的 SDL first 開發流程角度，簡介此可以取代傳統 ORM 的 DB toolkit。"}}},{"node":{"frontmatter":{"path":"blog/20191107","title":"Javascript Event loop - macro task & micro task","tags":["javascript"],"excerpt":"介紹 Event loop 容易混淆的異步任務 macro task & micro task。"}}},{"node":{"frontmatter":{"path":"blog/20191125","title":"初探 RxJS（下）","tags":["rxjs"],"excerpt":"簡介上次未完的 RxJS 剩餘角色，和介紹目前公司後台專案使用的 redux-observable。"}}},{"node":{"frontmatter":{"path":"blog/20200518","title":"常用 NoSQL 雲端資料庫 - Part 1 MongoDB","tags":["mongodb"],"excerpt":"簡介 Relational/NoSQL database、mongoose ORM 寫 mongo CRUD API。"}}},{"node":{"frontmatter":{"path":"blog/20190907","title":"GraphQL & Apollo Client","tags":["apollo"],"excerpt":"簡單介紹 React Client 端如何用 Apollo 對 GraphQL Server 做資料存取操作。"}}},{"node":{"frontmatter":{"path":"blog/20190906","title":"初探 Storybook","tags":["javascript"],"excerpt":"初探這款能夠在開發前端元件或是函式庫的同時，可以快速地建立元件各種操作模式或是樣式的工具。"}}},{"node":{"frontmatter":{"path":"blog/20190906-2","title":"React Hooks - useCallback, useMemo, useRef","tags":["reactjs"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20191017","title":"初探 RxJS（上）","tags":["rxjs"],"excerpt":"簡介相關的設計模式中的 Behavioral Pattern，再介紹 RxJS（先講 Observable）"}}},{"node":{"frontmatter":{"path":"blog/20190707","title":"JavaScript HTML5 Web Worker & CRA 使用踩雷","tags":["javascript"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20190108","title":"JavaScript 認識非同步 Callback, Promise, async/await","tags":["javascript"],"excerpt":"Asynchronous 非同步的不同寫法的整理筆記。"}}},{"node":{"frontmatter":{"path":"blog/20170728","title":"WebForm 註冊 JavaScript","tags":["asp.net","javascript"],"excerpt":"動態產生JS在目前公司專案中是滿常用到的小技巧，不同的用法會產生在Web Page 的不同位置而有直譯式語言的前後順序差。"}}},{"node":{"frontmatter":{"path":"blog/20170604","title":"Web App 推播通知","tags":["asp.net"],"excerpt":"隨著行動和穿載裝置的興起，推播通知 (Push Notification) 成為維繫App用戶關係相當有力的工具"}}},{"node":{"frontmatter":{"path":"blog/20180514","title":"JavaScript 中 this 指向","tags":["javascript"],"excerpt":"簡介 this 指向的六種情況。"}}},{"node":{"frontmatter":{"path":"blog/20180521","title":"Web 常見攻擊手法","tags":["security"],"excerpt":"擁有基本的資安觀念保護好自家資料和 user 使用環境是開發人員重要的一點。"}}},{"node":{"frontmatter":{"path":"blog/20170421","title":"存取遠端 EventLog","tags":["asp.net","javascript"],"excerpt":"在公司中實作一個 Event log 的查詢工具。（之後來寫了 D3 呈現查詢異常查詢的部分）"}}},{"node":{"frontmatter":{"path":"blog/20170714","title":"WebForm 使用 reCAPTCHA 驗證","tags":["asp.net"],"excerpt":"這個我不是機器人驗證一定不陌生，滿多登入畫面會看到的，剛好今天接到把圖形驗證改為 reCAPTCHA 就順手記下。"}}},{"node":{"frontmatter":{"path":"blog/20170508","title":"WebForm 圖片上傳檢查","tags":["asp.net"],"excerpt":"開放上傳有可能被傳奇怪東西的風險，只檢查所看到的副檔名，謹慎來說似乎是不夠的。"}}}]}},"pageContext":{"postPath":"blog/20200630","translations":[{"hreflang":"en","path":"/blog/20200630"}]}},"staticQueryHashes":["4097791827"]}