{"componentChunkName":"component---src-templates-post-post-jsx","path":"/blog/20191017","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>預計簡介相關的設計模式中的 Behavioral Pattern，再介紹 RxJS（先講 Observable），後面再帶到 redux-observable（會分次分享</p>\n</blockquote>\n<p>先介紹一下相關的 Behavioral Pattern...</p>\n<h2>Observer Pattern 觀察者模式</h2>\n<ul>\n<li>\n<p>定義物件間（Subject 目標和 Observer 觀察者）的一種<strong>一對多</strong>的依賴關係，當一個物件的狀態發生變化時，所有依賴於它的物件都得到通知並被自動更新。</p>\n<ul>\n<li>觀察者和目標是<strong>單向依賴</strong>的，只有觀察者依賴於目標，聯繫的主動權也是在目標手中</li>\n<li>觀察者和目標是松耦合 loosely coupled 聯繫，彼此不需知道內部的細節，就可以通信</li>\n<li>此處一對多是抽象概念，例如一位 YouTuber 可以被很多觀眾訂閱</li>\n</ul>\n</li>\n<li>\n<p>觀察者模式由 Subject 目標和 Observer 觀察者（訂閱者）組成。\n<img src=\"https://i.imgur.com/DFVcwRs.png\"></p>\n<ul>\n<li>Subject 負責發布事件、增加或減少訂閱者</li>\n<li>Observer 負責訂閱這些事件來觀察 Subject，提供 Subject 通知時對應的更新方法，Subject 可以被多個 Observer 訂閱</li>\n</ul>\n</li>\n<li>\n<p>舉例：\n喜歡某 YouTuber 並訂閱他影片加進訂閱者清單，有新影片就會通知這些訂閱者，不喜歡時可以取消訂閱移出清單就不會再接受通知。</p>\n<ul>\n<li>\n<p>角色</p>\n<ul>\n<li>YouTuber → 目標 Subject</li>\n<li>會有三個行為：「加入訂閱」、「移除訂閱」、「通知訂閱的人」</li>\n<li>訂閱的人 → 觀察者 Observer</li>\n</ul>\n</li>\n<li>\n<p>情況</p>\n<ul>\n<li>一個 YouTuber 可以有多個訂閱者</li>\n<li>用戶（訂閱者）可以同時訂閱多位 YouTuber</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>基本實作需實現：</p>\n<ul>\n<li>Subject 要能維護 Observer 的註冊信息</li>\n<li>Subject 要能維護引起通知的狀態</li>\n<li>Observer 要能接收 Subject 的通知</li>\n<li>如果是一個 Observer 訂閱多個 Subject，Observer 的更新方法中要判斷是來自哪個 Subject</li>\n</ul>\n</li>\n</ul>\n<h2>Pub-Sub Pattern 發布訂閱模式</h2>\n<ul>\n<li>\n<p>也擁有訂閱與被訂閱的關係，Pub-Sub Pattern 是由 Publisher 發布者和 Subscriber 訂閱者組成。\n但和觀察者模式不同的是，Publisher 和 Subscriber 間是<strong>透過第三者 Broker / message broker / event bus 中間人來溝通</strong>。</p>\n<ul>\n<li>Pub-Sub Pattern 不是松耦合，是完全解偶的，Publisher 和 Subscriber 間不存在耦合\n<img src=\"https://i.imgur.com/qqUjDC9.png\"></li>\n<li>實作上較常見 Broker 以 Topic-based 和 Content-based 作為 filter 方式</li>\n<li>\n<p>舉例：\n當 Publisher 發布主旨為 A 的消息，Broker 就會將消息推送給有訂閱了主旨為 A 的 Subscriber。</p>\n<ul>\n<li>也可以實現成 Subscriber 主動來拉取</li>\n</ul>\n</li>\n<li>適合用於不相知的相異系統間的溝通方式</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://i.imgur.com/E93iAto.png\"></p>\n<p>兩模式的訂閱者與被訂閱者間差異概述：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Observer Pattern</th>\n<th align=\"center\">Pub-Sub Pattern</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">Subject 直接通知 Observer</td>\n<td align=\"center\">由 Broker 推送消息給 Subscriber</td>\n</tr>\n<tr>\n<td align=\"center\">松耦合</td>\n<td align=\"center\">無耦合關係</td>\n</tr>\n<tr>\n<td align=\"center\">較常以同步方式實作</td>\n<td align=\"center\">較常以非同步方式實作</td>\n</tr>\n<tr>\n<td align=\"center\">較常 single application 應用</td>\n<td align=\"center\">較常 cross-application 應用</td>\n</tr>\n</tbody>\n</table>\n<h2>Iterator Pattern 迭代器模式</h2>\n<ul>\n<li>讓一個集合，例如 list, stack, tree 等等，不用暴露裡面的實作細節，就可以遍歷其各個元素。</li>\n<li>\n<p>Iterator 提供外部訪問資料的方法：</p>\n<ul>\n<li><code>current()</code>: 取得當前訪問的資料元素</li>\n<li><code>next()</code>: 取得下一個資料元素</li>\n<li><code>key()</code>: 取得當前訪問資料元素的 key 值</li>\n<li><code>hasNext()</code>: 是否還有下一個資料元素</li>\n<li><code>rewind()</code>: 回到第一個資料元素</li>\n</ul>\n</li>\n<li>擁有漸進式取得資料的特性，可以拿來做延遲運算（Lazy evaluation 或 call-by-need）</li>\n<li>iterator 本身是序列，所以可以實作所有陣列的運算方法像 map, filter... 等</li>\n</ul>\n<h1>RxJS 簡介</h1>\n<ul>\n<li>\n<p><a href=\"https://github.com/dotnet/reactive\" target=\"_blank\" rel=\"nofollow\">Reactive Extensions (Rx)</a> is a library for composing asynchronous and event-based programs using observable sequences and LINQ-style query operators.\n→ 使用 Observables 序列來編寫異步和基於事件的程序的 library\n→ 處理事件的 lodash 角色</p>\n<ul>\n<li>Rx = Observables + LINQ + Schedulers</li>\n<li>Observables 代表異步的 data stream 資料流</li>\n<li>LINQ operators 則是 query 異步資料流的方式（幫助控制事件如何流經 Observables）</li>\n<li>\n<p>Schedulers 是將<strong>並發性</strong>的異步資料流參數化的方式</p>\n<ul>\n<li>並發性 Concurrency：Multi-thread，會將工作拆成數個子任務並分派給多個 thread 同時運行（<a href=\"https://medium.com/mr-efacani-teatime/concurrency%E8%88%87parallelism%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E8%99%95-1b212a020e30\" target=\"_blank\" rel=\"nofollow\">Concurrency 與 Parallelism 的不同之處</a>有時間可看）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>核心觀念</p>\n<ul>\n<li>\n<p>Thinking Reactively：Reactive Programming 響應式編程\n當事件發生（變數或資源發生變動）能反應，asynchronous data streams 為中心思想出發的程式撰寫方式，適合解決複雜的非同步行為。 * 容易搞混的 Observable 可被觀察的、Observer 觀察者\n→ 當<strong>可被觀察的東西</strong>有事情發生，<strong>觀察者</strong>就可以做出反應\n→ 當訂閱了某個 Observable，只要事件發生就會執行傳進去的 function</p>\n<div class=\"warning\">\n可以把 Observable 想成是 stream 資料流\n→ 時間序列上的一連串資料事件\n→ 會一直增加元素的陣列\n→ 多了時間維度的陣列\n</div>\n</li>\n<li>Functional Programming（FP）</li>\n<li>Expression, no Statement → 只有表達式</li>\n<li>函式為一等公民 (First Class) → 函式能夠被賦值給變數，也能夠被當作參數傳入另一個函式，也可當作一個函式的回傳值</li>\n<li>Pure Function → 相同輸入、相同輸出，沒有 Side Effect（例如：Array 中的 <code>slice</code> 是，但 <code>splice</code> 不是）</li>\n<li>優點：可讀性高、好維護、易於並行處理</li>\n</ul>\n</li>\n<li>\n<p>所以在進入 RxJS 前讓我們先了解一下其所擁有的角色與觀念，可列為下：</p>\n<ul>\n<li>Observable 可觀察對象</li>\n<li>Observer 觀察者</li>\n<li>Subscription 訂閱</li>\n<li>Operators 操作符</li>\n<li>Subject 主體</li>\n<li>Schedulers 調度器</li>\n</ul>\n</li>\n</ul>\n<p>這次分享主要是前面三個\n<a href=\"https://rxjs-cn.github.io/learn-rxjs-operators/about/\" target=\"_blank\" rel=\"nofollow\">Operators</a> 有興趣可以先自己略看個，先了解手上有哪些工具可用（？</p>\n<blockquote>\n<p>每個 Operator 都會回傳一個新的 Observable</p>\n</blockquote>\n<p>RxJS 5.5 後官方建議改成 <a href=\"https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md\" target=\"_blank\" rel=\"nofollow\">Pipeable</a> 寫法，用到的 <code>pipe</code> operator 會留到下次說明，先知道這篇的寫法都可以改成 Pipeable 寫法\n它可以使得可讀性更高、打包後更小</p>\n<ul>\n<li><a href=\"https://cn.rx.js.org/manual/usage.html#h11\" target=\"_blank\" rel=\"nofollow\">RxJS 中文文檔-Pipeable 操作符</a></li>\n<li><a href=\"https://stackoverflow.com/questions/48668701/what-is-pipe-for-in-rxjs\" target=\"_blank\" rel=\"nofollow\">stack overflow - What is pipe for in rxJS</a></li>\n</ul>\n<h3>Observable 可觀察對象（被觀察的）</h3>\n<ul>\n<li>可以想成是多了時間維度的陣列</li>\n<li>\n<p>可以同時處理同步跟非同步，並推送零個或多個值給觀察者的行為</p>\n<ul>\n<li>由於有時候是非同步有時候是同步，使得常搞不清楚 Observable 何時送元素，也不好除錯，而 Scheduler 可以處理此問題</li>\n</ul>\n</li>\n<li>被訂閱時才會執行（要提供 Observer），同個 Observable 可以被多次訂閱</li>\n<li>Observable 跟 Observer Pattern 是不同的，Observable 內部並沒有管理一份訂閱清單</li>\n<li>核心週期：創建、訂閱、執行、清理</li>\n<li>\n<p>Marble diagrams 彈珠圖可以幫助我們更容易地了解抽象的 observable operator 是如何處理資料流的</p>\n<ul>\n<li><a href=\"https://rxmarbles.com/\" target=\"_blank\" rel=\"nofollow\">RxJS Marbles</a></li>\n</ul>\n</li>\n</ul>\n<p>先快速介紹一些 Operator，沒講到的可以去看看 <a href=\"https://rxjs-cn.github.io/learn-rxjs-operators/\" target=\"_blank\" rel=\"nofollow\">學習 RxJS 操作符</a></p>\n<h4>創建 Observable - <a href=\"https://rxjs-cn.github.io/learn-rxjs-operators/operators/creation/\" target=\"_blank\" rel=\"nofollow\">Creation Operators</a></h4>\n<ul>\n<li>\n<p><code>create(subscribe: function)</code> 是 Observable 構造函數的別名，接收一個參數：接受 observer 的 subscribe 函數（定義 observable 將會如何發送值，後面介紹）</p>\n<ul>\n<li>\n<p>Observable 可以被 observer 觀察者訂閱  </p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">var observable = Rx.Observable.create(function subscribe(observer) {\n// 可同步或異步的以 observer.next() 傳遞一或多個值\nobserver.next(100);\nsetInterval(() =&gt; {\nobserver.next(&#39;hi&#39;);\n}, 1000);\n});</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n</li>\n<li><code>of(...values, scheduler: Scheduler)</code><br>\n按順序發出任意數量的值 <a href=\"https://jsbin.com/lugayujohu/1/edit?js,console\" target=\"_blank\" rel=\"nofollow\">Example</a></li>\n<li>\n<p><code>from(ish: ObservableInput, mapFn: function, thisArg: any, scheduler: Scheduler)</code><br>\n可直接接收下列形式參數轉成 observable <a href=\"https://jsbin.com/mudebiluru/1/edit?js,console\" target=\"_blank\" rel=\"nofollow\">Example</a>  </p>\n<ol>\n<li>可列舉的參數（ex. Array, Set, WeakSet, Iterator）</li>\n<li>或 單純字串（會拆成字元）</li>\n<li>或 Promise（也可用 <code>fromPromise</code> operator，同結果）</li>\n</ol>\n</li>\n<li>\n<p><code>fromEvent(target: EventTargetLike, eventName: string, selector: function)</code><br>\n可以將事件轉換成 observable</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">Rx.Observable.fromEvent(DOM, &#39;click&#39;);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>適合搭配 takeUntil 來訂立釋放資源條件</li>\n</ul>\n</li>\n<li><code>timer(initialDelay: number | Date, period: number, scheduler: Scheduler)</code><br>\n給定持續時間後，再按照指定間隔時間依次發出數字 <a href=\"https://jsbin.com/qapovaguco/1/edit?js,console\" target=\"_blank\" rel=\"nofollow\">Example</a><br>\n等待時間可以是 ms 或 Date</li>\n<li><code>interval(period: number, scheduler: Scheduler)</code><br>\n基於給定時間間隔發出從 0 開始數字序列</li>\n</ul>\n<p>...</p>\n<h4>轉換 Observable - <a href=\"https://rxjs-cn.github.io/learn-rxjs-operators/operators/transformation/\" target=\"_blank\" rel=\"nofollow\">Transformation Operators</a></h4>\n<ul>\n<li><code>map(callback function)</code><br>\ncallback function 會帶入每次發送元素，再回傳改變後的新元素</li>\n<li><code>mapTo(value)</code><br>\n可以把傳進來的值改變成固定值</li>\n<li><code>filter(callback function)</code></li>\n<li><code>take(取前n個)</code></li>\n<li><code>first()</code> = take(1)</li>\n<li><code>skip(忽略前n個)</code></li>\n<li><code>takeLast(取最後n個)</code><br>\n必須等到整個 observable 完成(complete)，才能知道最後的元素有哪些，並且同步送出\n<img src=\"https://i.imgur.com/H7w1RqT.png\"></li>\n<li><code>last()</code> = takeLast(1)</li>\n<li><a href=\"https://rxmarbles.com/#takeUntil\" target=\"_blank\" rel=\"nofollow\"><code>takeUntil(Observable)</code></a><br>\n當某件事情發生時 complete<br>\n<code>javascript var click = Rx.Observable.fromEvent(document.body, 'click'); var example = source.takeUntil(click);</code>\n...</li>\n</ul>\n<h3>組合 Observable - <a href=\"https://rxjs-cn.github.io/learn-rxjs-operators/operators/combination/\" target=\"_blank\" rel=\"nofollow\">Combination Operators</a></h3>\n<ul>\n<li><a href=\"https://jsbin.com/lenahaxoze/edit?js,console,output\" target=\"_blank\" rel=\"nofollow\"><code>concatAll()</code></a><br>\n會<strong>依序</strong>處理待合併的 observable <a href=\"https://jsbin.com/cibikiwale/1/edit?js,console,output\" target=\"_blank\" rel=\"nofollow\">Example</a></li>\n<li><code>concatMap(callback function)</code><br>\n當 map 加上 concatAll 就可以使用簡化寫法的 <code>concatMap</code> <a href=\"https://jsbin.com/sovadefexe/1/edit?js,console,output\" target=\"_blank\" rel=\"nofollow\">Example</a><br>\n<img src=\"https://i.imgur.com/t5lJ3v7.png\"></li>\n<li>\n<p><code>concat(observable arguments...)</code><br>\n可以把多個 observable 實例合併成一個，跟 concatAll 一樣，必須先等前一個 observable 完成(complete)，才會繼續下一個</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">var source = Rx.Observable.interval(1000).take(3);\nvar source2 = Rx.Observable.of(3);\nvar source3 = Rx.Observable.of(4, 5, 6);\nvar example = source.concat(source2, source3);</code>\n        </deckgo-highlight-code>\n<p><img src=\"https://i.imgur.com/zaeJWUa.png\"></p>\n</li>\n<li><code>startWith(初始要發送的元素)</code><br>\n一開始就同步發出，常被用來保存程式的起始狀態<br>\n<img src=\"https://i.imgur.com/uGPS8NK.png\"></li>\n<li><code>merge(Observable)</code> 似 OR<br>\nmerge 跟 concat 一樣都是用來合併 observable，差在 <strong>merge 是同時處理行為，而 concat 是一個一個依序處理</strong>  </li>\n<li>\n<p><a href=\"https://jsbin.com/posutey/2/edit?js,console\" target=\"_blank\" rel=\"nofollow\"><code>zip(observable arguments..., callback function)</code></a><br>\n取每個 observable 相同順位的元素並傳入 callback\n<img src=\"https://i.imgur.com/CiBzfMG.png\"></p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">var source = Rx.Observable.interval(500).take(3);\nvar newest = Rx.Observable.interval(300).take(6);\n\nvar example = source.zip(newest, (x, y) =&gt; x + y);\n\nexample.subscribe({\nnext: (value) =&gt; {\n  console.log(value);\n},\nerror: (err) =&gt; {\n  console.log(&#39;Error: &#39; + err);\n},\ncomplete: () =&gt; {\n  console.log(&#39;complete&#39;);\n},\n});\n// 0\n// 2\n// 4\n// complete</code>\n        </deckgo-highlight-code>\n<p><img src=\"https://i.imgur.com/Kxu35Sv.png\"><br>\nzip 注意：因為 zip 要 cache 為處理的元素，當 observable 快慢差很大時由於會 cache 大量元素就可能造成記憶體相關問題</p>\n</li>\n</ul>\n<p>...</p>\n<p>還有很多 Operator 這邊就不繼續贅述了 ⋯⋯</p>\n<p>補充：Observable 較 Array 不同的特性</p>\n<ul>\n<li>\n<p>延遲運算（Lazy evaluation 或 call-by-need）：<br>\nObservable 會等到訂閱後才開始對元素做運算，如果沒有訂閱就不會有運算的行為  </p>\n<ul>\n<li>函數和 Observables 都是惰性運算（需要調用才執行）</li>\n</ul>\n</li>\n<li>\n<p>漸進式取值：\n陣列的 operators 都必須完整的運算出每個元素的返回值並組成一個陣列，再做下一個 operator 的運算<br>\n<img src=\"http://i.giphy.com/l0HlPZeB9OvFu7QwE.gif\"><br>\nObservable 每次的運算是一個元素運算到底再返回（漸進式取值）<br>\n<img src=\"http://i.giphy.com/3o6ZtqrBfUyHvMDQ2c.gif\">  </p>\n<ul>\n<li>Iterator Pattern &#x26; Observer Pattern 都是漸進式取值為共同特性</li>\n<li>但 Observer 是 Producer push 資料；Iterator 是 Consumer pull 資料</li>\n<li>Observable 是兩模式思想的結合</li>\n<li>漸進式取值特性在處理大量資料時也會比要高效</li>\n</ul>\n</li>\n</ul>\n<h3>Observer 觀察者</h3>\n<ul>\n<li>\n<p>用來訂閱 Observable 的物件（回調函數的集合）</p>\n<ul>\n<li>定義 next, error, complete 三方法的行為</li>\n</ul>\n</li>\n<li><a href=\"https://jsbin.com/fuxeleyudi/1/edit?js,console\" target=\"_blank\" rel=\"nofollow\">Example</a>\n<img src=\"https://i.imgur.com/pLybQLu.png\"></li>\n<li>訂閱 Observable 不一定要用 Observer 物件訂閱，也可以將三方法依照 next, error, complete 順序直接代入，它會自動內部生成 Observer</li>\n</ul>\n<h3>[動作] Subscribe 訂閱</h3>\n<ul>\n<li>創建的 Observable 被 subscribe 時才會執行 → 訂閱一個 Observable 就像是執行一個 function</li>\n<li>\n<p><a href=\"https://jsbin.com/cexadakijo/1/edit?js,console\" target=\"_blank\" rel=\"nofollow\">Example</a></p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">// observable 可以同時處理異步或同步\nvar observable = Rx.Observable.create(function(observer) {\nobserver.next(&#39;Apple&#39;);\nobserver.next(&#39;Peach&#39;);\n\nsetTimeout(() =&gt; {\n  observer.next(&#39;Strawberry&#39;);\n}, 30);\n});\n\nconsole.log(&#39;start&#39;);\nobservable.subscribe((value) =&gt; {\nconsole.log(value);\n});\nconsole.log(&#39;end&#39;);</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p>Question.<br>\nps. subscribe 本身是同步</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">var observable = Rx.Observable.create(function(observer) {\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n  setTimeout(() =&gt; {\n    observer.next(4);\n    observer.complete();\n    observer.next(5);\n  }, 1000);\n  observer.next(6);\n});\n\nconsole.log(&#39;just before subscribe&#39;);\nobservable.subscribe({\n  next: (x) =&gt; console.log(&#39;got value &#39; + x),\n  error: (err) =&gt; console.error(&#39;something wrong occurred: &#39; + err),\n  complete: () =&gt; console.log(&#39;done&#39;),\n});\nconsole.log(&#39;just after subscribe&#39;);</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://jsbin.com/wugahevoxu/1/edit?js,console\" target=\"_blank\" rel=\"nofollow\">jsbin</a></p>\n<h3>Subscription 訂閱（舊版 RxJS 叫 Disposable）</h3>\n<ul>\n<li><code>observable.subscribe()</code> 調用 Observable 時會返回的一個 Subscription 訂閱對象（Observable 的執行）</li>\n<li>可被清理資源的對象：當中有 <code>unsubscribe()</code> 方法可以清理由 Subscription 所佔用的資源</li>\n<li>\n<p>Subscription 還可以合體成 Subscriptions，可以一起取消訂閱或取消已添加的其中一個訂閱 <code>remove(otherSubscription)</code></p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\"  >\n          <code slot=\"code\">var observable1 = Rx.Observable.interval(500);\nvar observable2 = Rx.Observable.interval(800);\n\nvar subscription = observable1.subscribe((x) =&gt; console.log(&#39;first: &#39; + x));\nvar childSubscription = observable2.subscribe((x) =&gt; console.log(&#39;second: &#39; + x));\n\nsubscription.add(childSubscription);\nsetTimeout(() =&gt; {\n// subscription 和 childSubscription 一起被清理\nsubscription.unsubscribe();\n}, 1000);</code>\n        </deckgo-highlight-code>\n</li>\n<li>若希望第二次訂閱 source 不會從頭開始接收元素，而是從第一次訂閱到當前處理的元素開始發送，我們把這種處理方式稱為組播(multicast)（下次再分享</li>\n<li>訂閱 Observable 跟 addEventListener 在實作上其實有非常大的不同，Observable 並沒有管理一個訂閱的清單</li>\n</ul>\n<h3>[動作] Unsubscribe 清理（退訂）</h3>\n<ul>\n<li>用 Subscription 的 <code>unsubscribe()</code> 函數去取消 Observable 執行來釋放資源，避免浪費計算能力或內存資源</li>\n</ul>\n<p>今天先介紹最基本主要的這三個角色</p>\n<p>知道 Observable 中最基本角色與行為後，就來個實作結尾吧～</p>\n<ol>\n<li>\n<p>實作 Auto complete</p>\n<ul>\n<li>input 輸入時下方有建議列表並可點選取代 input 值，且期望輸入停頓隔 100ms 再 call 列表 api</li>\n<li>\n<p>用 wiki 開放 api <code>https://zh.wikipedia.org/w/api.php?action=opensearch&#x26;format=json&#x26;limit=5&#x26;origin=*&#x26;search=</code>關鍵字</p>\n<ul>\n<li>回來結果會是陣列，第一個是 string keyword，第二個是 string array 結果，後面不管</li>\n</ul>\n</li>\n<li>需使用的 Operators 提示</li>\n<li><a href=\"https://rxjs-cn.github.io/learn-rxjs-operators/operators/filtering/filter.html\" target=\"_blank\" rel=\"nofollow\"><code>filter</code></a></li>\n<li><a href=\"https://rxjs-cn.github.io/learn-rxjs-operators/operators/transformation/map.html\" target=\"_blank\" rel=\"nofollow\"><code>map</code></a></li>\n<li><a href=\"https://rxjs-cn.github.io/learn-rxjs-operators/operators/creation/fromevent.html\" target=\"_blank\" rel=\"nofollow\"><code>fromEvent</code></a></li>\n<li>\n<p><a href=\"https://rxjs-cn.github.io/learn-rxjs-operators/operators/transformation/switchmap.html\" target=\"_blank\" rel=\"nofollow\"><code>switchMap</code></a></p>\n<ul>\n<li>在每次發出時，會取消前一個內部 observable（你所提供的函數的結果）的訂閱，然後訂閱一個新的 observable</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://rxjs-cn.github.io/learn-rxjs-operators/operators/transformation/switchmap.html\" target=\"_blank\" rel=\"nofollow\"><code>debounceTime</code></a></p>\n<ul>\n<li>會捨棄掉在兩次輸出之間小於指定時間的發出值</li>\n</ul>\n</li>\n<li><a href=\"https://codepen.io/shiruco/pen/zYYBRZO?editors=0111\" target=\"_blank\" rel=\"nofollow\">codepen</a></li>\n</ul>\n</li>\n<li>\n<p>實作 拖拉 dom</p>\n<ul>\n<li>首先畫面上有一個元件(#drag)</li>\n<li>當滑鼠在元件(#drag)上按下左鍵(mousedown)時，開始監聽滑鼠移動(mousemove)的位置</li>\n<li>當滑鼠左鍵放掉(mouseup)時，結束監聽滑鼠移動</li>\n<li>當滑鼠移動(mousemove)被監聽時，跟著修改元件的樣式屬性</li>\n<li>需使用的 Operators 提示</li>\n<li><code>fromEvent</code></li>\n<li><code>map</code></li>\n<li><code>takeUntil</code></li>\n<li><code>concatAll</code></li>\n<li><a href=\"https://jsbin.com/kiwolitixo/edit?js,console,output\" target=\"_blank\" rel=\"nofollow\">jsbin</a></li>\n</ul>\n</li>\n<li>\n<p>實作 Canvas 畫畫</p>\n<ul>\n<li>可以左鍵按著畫出線條，放開就停畫</li>\n<li>需使用的 Operators 提示</li>\n<li><code>fromEvent</code></li>\n<li>\n<p><code>do</code></p>\n<ul>\n<li>執行某些操作或副作用</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://rxjs-cn.github.io/learn-rxjs-operators/operators/transformation/mergemap.html\" target=\"_blank\" rel=\"nofollow\"><code>mergeMap</code></a>（<code>flatMap</code>）</p>\n<ul>\n<li>映射成 observable 並發出值</li>\n</ul>\n</li>\n<li><code>mapTo</code></li>\n<li><code>takeUntil</code></li>\n<li><a href=\"https://codepen.io/shiruco/pen/yLLJdoY?editors=1011\" target=\"_blank\" rel=\"nofollow\">codepen</a></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2>References</h2>\n<ul>\n<li><a href=\"https://medium.com/enjoy-life-enjoy-coding/design-pattern-%E5%8F%AA%E8%A6%81%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93-%E6%88%91%E5%B0%B1%E5%91%8A%E8%A8%B4%E4%BD%A0-%E8%A7%80%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-observer-pattern-feat-typescript-8c15dcb21622\" target=\"_blank\" rel=\"nofollow\">Design Pattern | 只要你想知道，我就告訴你 - 觀察者模式（ Observer Pattern ） feat. TypeScript</a></li>\n<li><a href=\"https://www.jianshu.com/p/aa7ee3c96986\" target=\"_blank\" rel=\"nofollow\">【行为型模式十八】观察者模式（Observer）</a></li>\n<li><a href=\"https://hackernoon.com/observer-vs-pub-sub-pattern-50d3b27f838c\" target=\"_blank\" rel=\"nofollow\">Observer vs Pub-Sub pattern</a></li>\n<li><a href=\"https://ithelp.ithome.com.tw/articles/10227583\" target=\"_blank\" rel=\"nofollow\">[Day28] 操作大量資料的好幫手 ─ 迭代器(Iterator) &#x3C;模式篇></a></li>\n<li><a href=\"https://blog.techbridge.cc/2017/12/08/rxjs/\" target=\"_blank\" rel=\"nofollow\">希望是最淺顯易懂的 RxJS 教學</a></li>\n<li><a href=\"https://cn.rx.js.org/manual/tutorial.html\" target=\"_blank\" rel=\"nofollow\">教程| RxJS 中文文档</a></li>\n<li><a href=\"https://ithelp.ithome.com.tw/users/20103367/ironman/1199\" target=\"_blank\" rel=\"nofollow\">30 天精通 RxJS</a></li>\n<li><a href=\"https://rxjs-cn.github.io/learn-rxjs-operators/about/\" target=\"_blank\" rel=\"nofollow\">学习 RxJS 操作符</a></li>\n</ul>","timeToRead":15,"frontmatter":{"title":"初探 RxJS（上）","date":"06 Sep 2019","tags":["rxjs"],"path":"blog/20191017","excerpt":"簡介相關的設計模式中的 Behavioral Pattern，再介紹 RxJS（先講 Observable）"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"blog/20210110","title":"Pop Quiz","tags":["javascript"],"excerpt":"記錄踩到的陷阱題。"}}},{"node":{"frontmatter":{"path":"blog/20210109","title":"Response Set-Cookie 無效","tags":["apollo"],"excerpt":"記錄個之前在和同事們弄 Side project 時犯蠢遇到的問題與解決方式。"}}},{"node":{"frontmatter":{"path":"blog/20210109-3","title":"REST / RESTful & HTTP Methods","tags":["javascript"],"excerpt":"簡易整理。"}}},{"node":{"frontmatter":{"path":"blog/20210109-2","title":"IntersectionObserver","tags":["javascript"],"excerpt":"公司專案有個日期連動的 scroll 優化試驗，原先是監聽 scroll。"}}},{"node":{"frontmatter":{"path":"blog/20200910","title":"Apollo Server 入門篇","tags":["apollo"],"excerpt":"快速複習去年分享的 GraphQL Schema 和 Client query 語法，並簡介如何以 Apollo Server 建立 GraphQL Server。"}}},{"node":{"frontmatter":{"path":"blog/20200630","title":"Express - Authentication, Authorization and Security","tags":["security","express"],"excerpt":"簡介 Express RESTful API Server 範例中 JWT 權限、授權相關。"}}},{"node":{"frontmatter":{"path":"blog/20190909","title":"Prisma - Schema, Data Model, Relations, Client","tags":["prisma"],"excerpt":"未來 Side project 可能會應用到的 SDL first 開發流程角度，簡介此可以取代傳統 ORM 的 DB toolkit。"}}},{"node":{"frontmatter":{"path":"blog/20200527","title":"常用 NoSQL 雲端資料庫 - Part 2 Firebase","tags":["firebase"],"excerpt":"簡介 Google 提供的後端服務平臺（BaaS）中的兩種 DB，realtime database 和 cloud firestore。"}}},{"node":{"frontmatter":{"path":"blog/20200518","title":"常用 NoSQL 雲端資料庫 - Part 1 MongoDB","tags":["mongodb"],"excerpt":"簡介 Relational/NoSQL database、mongoose ORM 寫 mongo CRUD API。"}}},{"node":{"frontmatter":{"path":"blog/20191125","title":"初探 RxJS（下）","tags":["rxjs"],"excerpt":"簡介上次未完的 RxJS 剩餘角色，和介紹目前公司後台專案使用的 redux-observable。"}}},{"node":{"frontmatter":{"path":"blog/20190906","title":"初探 Storybook","tags":["javascript"],"excerpt":"初探這款能夠在開發前端元件或是函式庫的同時，可以快速地建立元件各種操作模式或是樣式的工具。"}}},{"node":{"frontmatter":{"path":"blog/20190907","title":"GraphQL & Apollo Client","tags":["apollo"],"excerpt":"簡單介紹 React Client 端如何用 Apollo 對 GraphQL Server 做資料存取操作。"}}},{"node":{"frontmatter":{"path":"blog/20190707","title":"JavaScript HTML5 Web Worker & CRA 使用踩雷","tags":["javascript"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20191107","title":"Javascript Event loop - macro task & micro task","tags":["javascript"],"excerpt":"介紹 Event loop 容易混淆的異步任務 macro task & micro task。"}}},{"node":{"frontmatter":{"path":"blog/20180514","title":"JavaScript 中 this 指向","tags":["javascript"],"excerpt":"簡介 this 指向的六種情況。"}}},{"node":{"frontmatter":{"path":"blog/20180521","title":"Web 常見攻擊手法","tags":["security"],"excerpt":"擁有基本的資安觀念保護好自家資料和 user 使用環境是開發人員重要的一點。"}}},{"node":{"frontmatter":{"path":"blog/20170714","title":"WebForm 使用 reCAPTCHA 驗證","tags":["asp.net"],"excerpt":"這個我不是機器人驗證一定不陌生，滿多登入畫面會看到的，剛好今天接到把圖形驗證改為 reCAPTCHA 就順手記下。"}}},{"node":{"frontmatter":{"path":"blog/20170604","title":"Web App 推播通知","tags":["asp.net"],"excerpt":"隨著行動和穿載裝置的興起，推播通知 (Push Notification) 成為維繫App用戶關係相當有力的工具"}}},{"node":{"frontmatter":{"path":"blog/20190108","title":"JavaScript 認識非同步 Callback, Promise, async/await","tags":["javascript"],"excerpt":"Asynchronous 非同步的不同寫法的整理筆記。"}}},{"node":{"frontmatter":{"path":"blog/20170728","title":"WebForm 註冊 JavaScript","tags":["asp.net","javascript"],"excerpt":"動態產生JS在目前公司專案中是滿常用到的小技巧，不同的用法會產生在Web Page 的不同位置而有直譯式語言的前後順序差。"}}},{"node":{"frontmatter":{"path":"blog/20170508","title":"WebForm 圖片上傳檢查","tags":["asp.net"],"excerpt":"開放上傳有可能被傳奇怪東西的風險，只檢查所看到的副檔名，謹慎來說似乎是不夠的。"}}},{"node":{"frontmatter":{"path":"blog/20190906-2","title":"React Hooks - useCallback, useMemo, useRef","tags":["reactjs"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20170421","title":"存取遠端 EventLog","tags":["asp.net","javascript"],"excerpt":"在公司中實作一個 Event log 的查詢工具。（之後來寫了 D3 呈現查詢異常查詢的部分）"}}}]}},"pageContext":{"postPath":"blog/20191017","translations":[{"hreflang":"en","path":"/blog/20191017"}]}},"staticQueryHashes":["4097791827"]}