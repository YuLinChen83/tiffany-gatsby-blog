{"componentChunkName":"component---src-templates-post-post-jsx","path":"/blog/20190909","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://hackmd.io/mOTKzMwoRyaDvP2NkyV6MQ?view\" target=\"_blank\" rel=\"nofollow\">HackMD</a></p>\n<blockquote>\n<p>Prisma replaces traditional ORMs and can be used to build GraphQL servers, REST APIs, microservices &#x26; more.</p>\n</blockquote>\n<h1>Prisma Schema</h1>\n<ul>\n<li>我們採用 <code>schema.prisma</code> 定義完 prisma schema 後，才建立、修改 MySQL 的 Tables 的方式，所以從這開始</li>\n<li>想了解對應的 sql 語句請<a href=\"https://www.prisma.io/docs/guides/database-workflows/unique-constraints-and-indexes\" target=\"_blank\" rel=\"nofollow\">自行參考 DATABASE WORKFLOWS 反推</a></li>\n</ul>\n<p>以下都是在 <code>schema.prisma</code> 裡</p>\n<h2>Generators</h2>\n<p>指定 <code>prisma generate</code> 產的 assets</p>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">generator client {\n  provider      = &quot;prisma-client-js&quot;\n  output        = &quot;node_modules/@prisma/client&quot; # default\n  binaryTargets = [&quot;native&quot;]    # default 指定為目前的 OS\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li><code>provider</code> required：目前用 <code>prisma-client-js</code></li>\n<li><code>output</code> optinal：Prisma Client 位置（Default: node_modules/@prisma/client）</li>\n<li>\n<p><a href=\"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema/generators/#binary-targets\" target=\"_blank\" rel=\"nofollow\"><code>binaryTargets</code> optional</a>：指定 Prisma Client run 在哪個 OS</p>\n<ul>\n<li>例：Mac OS <code>binaryTargets = [\"darwin\"]</code></li>\n</ul>\n</li>\n</ul>\n<h2>Specify a MySQL data source</h2>\n<p><code>schema.prisma</code> 最上方\nMySQL connection URL:<code>mysql://USER:PASSWORD@HOST:PORT/DATABASE</code>\n<img src=\"https://i.imgur.com/9ajoHE5.png\">\n<a href=\"https://www.prisma.io/docs/reference/database-connectors/mysql#connection-details\" target=\"_blank\" rel=\"nofollow\">Arguments 就有需求再來查，可以設定些連線相關</a></p>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">datasource mysql {\n  provider = &quot;mysql&quot;\n  url      = &quot;mysql://johndoe:mypassword@localhost:5432/mydb&quot;\n}</code>\n        </deckgo-highlight-code>\n<h2>Data Model</h2>\n<h3>Model, Scalar Type, Enum</h3>\n<ul>\n<li>Model 可以代表 db 的 table、prisma client queries 的基底</li>\n<li>Model 的 field 型別可以定義成 1. Scalar Type：String, Boolean, Int, Float, DateTime(Date), JSON(Object)、Enum * Enum：固定 constant 可以宣告成 enum\n<code>jsonld enum Role { USER ADMIN } model User { id Int @id @default(autoincrement()) role Role }</code> 2. Model（relation field）</li>\n<li>\n<p>Type modifiers：<code>[]</code>, <code>?</code></p>\n<ul>\n<li>List 的表示法 <code>MODELNAME[]</code>\nScalar list 只適用 data model（作為 relation field）\n例如 <code>posts Post[]</code> * 允許空值的 field 記得 TYPE 右邊加 <code>?</code>（optional），table 中會存為 NULL，例如 <code>headThumb String? @map(name: \"head_thumb\")</code>（List 例外它不需要加）；一般是 required</li>\n</ul>\n</li>\n<li>\n<p>Models、Fields、Enums naming：<code>[A-Za-z][A-Za-z0-9_]*</code></p>\n<ul>\n<li>Models、Enums 習慣 PascalCase</li>\n<li>Fields 習慣 camelCase</li>\n</ul>\n</li>\n</ul>\n<h3>Attributes, Functions</h3>\n<p>除了 List 以外，都可以配置 attribue 修飾符代表、約束，常用如</p>\n<ul>\n<li>\n<p>attributes（幾乎都有可以刪除的 argument name，可以約定都簡寫）\n<code>@</code> for field; <code>@@</code> for block</p>\n<ul>\n<li><code>@id</code> 每個 Model 最多一個</li>\n<li>field id 通常會搭配預設值，例 <code>@default(autoincrement())</code> 預設+1</li>\n<li>組合 id，例 <code>@@id([title, author])</code>、<code>@@id(fields: [title, author])</code></li>\n<li><code>@default(VALUE)</code> field 未給塞預設值</li>\n<li>例：<code>@default(now())</code>、<code>@default(value: autoincrement())</code></li>\n<li><code>@unique</code> 限制 field 唯一</li>\n<li>組合 fields <code>@@unique</code> 限制唯一，例 <code>@@unique([title, author])</code>、<code>@@unique(fields: [title, author])</code></li>\n<li>\n<p>補充：SQL 中 PRIMARY KEY 是用來保證欄位在資料表中的唯一性，主鍵欄位中的每一筆資料在資料表中都必需是獨一無二的（通常為 id）</p>\n<ul>\n<li>PRIMARY KEY 有點類似 UNIQUE 加上 NOT NULL</li>\n<li>一個資料表中只能有一個 PRIMARY KEY，但是可以有多個 UNIQUE</li>\n</ul>\n</li>\n<li><code>@@index</code> 建立索引，利於查詢效率（空間換速度）</li>\n<li>通常會在 Primary Key、Foreign Key 或常放在查詢子句中的 field 建立索引，例 <code>@@index([title, author])</code>、<code>@@index(fields: [title, author])</code></li>\n<li><code>@updatedAt</code> 有更動該筆資料時自動更新更新時間</li>\n<li><code>@map</code> 映射與 field 不同名的 table column；<code>@@map</code> 映射與 model 不同名的 table name</li>\n<li>例：<code>@map(\"is_admin\")</code>、<code>@map(name: \"is_admin\")</code></li>\n<li>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">          enum Role {\nADMIN     @map(&quot;admin&quot;)\nCUSTOMER  @map(&quot;customer&quot;)\n@@map(&quot;_Role&quot;)\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p><code>@relation</code> 關聯其他 model (table)，當中最複雜就它，後面再介紹。<a href=\"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema/relations#the-relation-attribute\" target=\"_blank\" rel=\"nofollow\">想先了解熟悉可看這</a></p>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">    @relation(fields: [userId], references: [id])\n@relation(fields: [userFirstName, userLastName], references: [firstName, lastName])\n@relation(name: &quot;UserOnPost&quot;, references: [id])\n@relation(&quot;UserOnPost&quot;, references: [id])\n# 關聯的都是 id 時可以省略 references\n@relation(name: &quot;UserOnPost&quot;)\n@relation(&quot;UserOnPost&quot;)</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n</li>\n<li>\n<p>functions (通常用在 default)</p>\n<ul>\n<li><code>autoincrement()</code> 新增的資料 id 自動 +1（Int）</li>\n<li><code>cuid()</code> 根據 cuid spec 產生 globally unique identifier</li>\n<li><code>uuid()</code> 根據 UUID spec 產生 globally unique identifier</li>\n<li><code>now()</code> 常用於新增資料的建立時間預設值（DateTime）</li>\n</ul>\n</li>\n</ul>\n<h2>Unique constraints <code>@unique</code></h2>\n<p>MySQL 的 constraint / index，在 prisma model 是設 <code>@unique</code> 限定唯一，可以單獨 column 設、也可以多個 column 組合成唯一（再另外命名），一張表可以有多個 unique\n可以在建立 table 時就先設好，或是建好的 table 再修改\nid 有 <code>@id</code> 就也是唯一了不需要給 <code>@unique</code></p>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">model User {\n  firstName String?\n  id        Int     @default(autoincrement()) @id # 這邊 default 是指不需要給它會自動+1\n  lastName  String?\n  account   String  @unique\n  @@unique([firstName, lastName], name: &quot;firstName&quot;)\n}</code>\n        </deckgo-highlight-code>\n<h2><a href=\"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema/relations\" target=\"_blank\" rel=\"nofollow\">Connect Model <code>@relation</code> 🔆</a></h2>\n<ul>\n<li>MySQL 表和表之間的關聯方式，建立表格時留個存關聯的表的 id 的 column，這個與外表關聯的 id 就是 foreign key（習慣叫 xxxId）；在 prisma model 間的關聯則是設 <code>@relation</code></li>\n<li>Relation fields：沒有 Scalar Type，其 Type 是其他 Model。每個表和表的關聯，兩方會各有一或多個 relation field</li>\n<li><code>@relation(_ name: String?, fields: FieldReference[]?, references: FieldReference[]?)</code></li>\n</ul>\n<p>Relation 有三種 <code>1-1</code>、<code>1-n</code>、<code>m-n</code>\n直接邊看範例邊了解：\nＱ：假設今天有 User、Profile、Category、Post 四個 Model，試著講出他們的關係：</p>\n<blockquote>\n<p>User ↔ Profile\nUser ↔ Post\nPost ↔ Category</p>\n</blockquote>\n<p>Ｑ：會怎麼實作 Model 會怎麼實作間的關聯？\n<img src=\"https://i.imgur.com/YNLZHl2.png\"></p>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">model User {\n  id      Int      @id @default(autoincrement())\n  posts   Post[]\n  profile Profile?\n}\nmodel Profile {\n  id      Int     @id @default(autoincrement())\n  user    User    @relation(fields: [userId], references: [id])\n  userId  Int\n}\nmodel Post {\n  id         Int         @id @default(autoincrement())\n  author     User        @relation(fields: [authorId], references: [id])\n  authorId   Int\n  categories Category[]  @relation(references: [id])\n}\nmodel Category {\n  id     Int     @id @default(autoincrement())\n  posts  Post[]  @relation(references: [id])\n}</code>\n        </deckgo-highlight-code>\n<h3>一對一 1-1 relation</h3>\n<p>情境：每個 User 可能會有自己的 Profile\n寫法一：forign key 在 Profile</p>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">model User {\n  id      Int      @id @default(autoincrement())\n  profile Profile?\n}\nmodel Profile {\n  id      Int     @id @default(autoincrement())\n  user    User    @relation(fields: [userId], references: [id])\n  userId  Int     // relation scalar field\n}</code>\n        </deckgo-highlight-code>\n<p><img src=\"https://i.imgur.com/32zx3NN.png\">\n寫法二：forign key 在 User</p>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">model User {\n  id         Int       @id @default(autoincrement())\n  profile    Profile?  @relation(fields: [profileId], references: [id])\n  profileId  Int?      // relation scalar field\n}\nmodel Profile {\n  id      Int     @id @default(autoincrement())\n  user    User\n}</code>\n        </deckgo-highlight-code>\n<p><img src=\"https://i.imgur.com/GoUQKya.png\">\n補充：multi-field IDs 時的 1-1</p>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">model User {\n  firstName String\n  lastName  String\n  profile   Profile?\n  @@id([firstName, lastName])\n}\nmodel Profile {\n  id               Int      @id @default(autoincrement())\n  user             User     @relation(fields: [authorFirstName, authorLastName], references: [firstName, lastName])\n  authorFirstName  String   // relation scalar field\n  authorLastName   String   // relation scalar field\n}</code>\n        </deckgo-highlight-code>\n<h3>一對多 1-n relation</h3>\n<p>forign key 會在 non-list field\n情境：每一 User 能有多篇 Post</p>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">model User {\n  id      Int      @id @default(autoincrement())\n  posts   Post[]\n}\nmodel Post {\n  id         Int         @id @default(autoincrement())\n  author     User        @relation(fields: [authorId], references: [id])\n  authorId   Int         # relation scalar field 關聯 User 的 foreign key\n}</code>\n        </deckgo-highlight-code>\n<p>上面的 <code>posts</code>、<code>author</code> 是 prisma 專屬產生關聯用法 Prisma Client 依據，database table 中<strong>不存在</strong>的 field；<code>authorId</code> 是<strong>存在</strong>於 table 的 forign key 得以關聯 User 和 Post<br>\n<img src=\"https://i.imgur.com/S7lL2ID.png%20=500x\"><br>\nspoiler 建立 relation 後 generate 的 Prisma Client 應用例子\n可以如下使用：</p>\n<ul>\n<li>\n<p>新增 User 同時新增他的 posts\n（user id 不用給是因為有 deafult；post authorId 則自動存為 user id）</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const userAndPosts = await prisma.user.create({\ndata: {\n  posts: {\n    create: [{ title: &#39;Prisma Day 2020&#39; }, { title: &#39;How to write a Prisma schema&#39; }],\n  },\n},\n});</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>查詢 User 可同時取得與他關聯的 posts</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const getAuthor = await prisma.user.findOne({\nwhere: {\n  id: &#39;20&#39;,\n},\ninclude: {\n  posts: true, // authorId == 20 的 post list\n},\n});</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>或是已存在沒有被關聯的 post，與已存在 User 做關聯</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const updateAuthor = await prisma.user.update({\nwhere: {\n  id: 20,\n},\ndata: {\n  posts: {\n    connect: {\n      id: 4,\n    },\n  },\n},\n});</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<p>注意 1-1 和 1-n relation 中</p>\n<ul>\n<li>\n<p>relations 中的 annotated relation field 和 relation scalar 必續同時 required 或是 optional，且 List Model 必為 required</p>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">model User {\nid        Int      @id @default(autoincrement())\nposts     Post[]\n}\nmodel Post {\nid        Int    @id @default(autoincrement())\nauthor    User?  @relation(fields: [authorId], references: [id])\nauthorId  Int?\n}</code>\n        </deckgo-highlight-code>\n</li>\n<li>1-1 forign key 關聯的必須是 unique；1-n 無限制</li>\n<li>\n<p><code>@relation</code> 只會在其中一邊</p>\n<ul>\n<li>一個 Model 同時有對同 Model 的多種關聯會有多個 <code>@relation</code>（要 disambiguate：命名區分）</li>\n<li>或是 self-relation：可以是 1-1, 1-n, m-n</li>\n<li>\n<p>Self-relations on the same model</p>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">    model User {\nid          Int      @id @default(autoincrement())\nname        String?\nhusband     User?    @relation(&quot;MarriagePartners&quot;)\nwife        User     @relation(&quot;MarriagePartners&quot;)\nteacher     User?    @relation(&quot;TeacherStudents&quot;)\nstudents    User[]   @relation(&quot;TeacherStudents&quot;)\nfollowedBy  User[]   @relation(&quot;UserFollows&quot;)\nfollowing   User[]   @relation(&quot;UserFollows&quot;)\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n</li>\n</ul>\n<h3>多對多 m-n relation（Implicit、explicit）</h3>\n<h4>Explicit 🔆</h4>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">model Post {\n  id         Int                 @id @default(autoincrement())\n  title      String\n  categories CategoriesOnPosts[]\n}\nmodel Category {\n  id    Int                 @id @default(autoincrement())\n  name  String\n  posts CategoriesOnPosts[]\n}\n# 表示 MySQL 經過 JOIN, link or pivot 的 table\nmodel CategoriesOnPosts {\n  post        Post     @relation(fields: [postId], references: [id])\n  postId      Int\n  category    Category @relation(fields: [categoryId], references: [id])\n  categoryId  Int\n  # createdAt DateTime @default(now()) 可以加些 meta-information\n  @@id([postId, categoryId])\n}</code>\n        </deckgo-highlight-code>\n<h4>Implicit</h4>\n<ul>\n<li>不用給 relation scalar field，除非是同時多個 self-relations</li>\n<li>\n<p>只能在 Model 都是 single <code>@id</code> 的情況使用（不可以是組合 id 或是 <code>@unique</code>），不符合的話就得選用 explicit 方式\n<img src=\"https://i.imgur.com/Nf4iCRE.png\"></p>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\"># 省略 @relation model Post { id Int @id @default(autoincrement()) categories Category[] } model Category { id Int @id @default(autoincrement()) posts Post[] }</code>\n        </deckgo-highlight-code>\n<p><img src=\"https://i.imgur.com/2fSTQl9.png\"><br>\n注意 m-n relation 中</p>\n</li>\n<li>\n<p>Implicit：兩邊都要 <code>@relation</code> 依據對方</p>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">model Post {\nid         Int        @id @default(autoincrement())\ncategories Category[] @relation(references: [id])\n}\n\nmodel Category {\nid       Int    @id @default(autoincrement())\nname     String\nposition Int\nposts    Post[] @relation(references: [id])\n}</code>\n        </deckgo-highlight-code>\n<p><img src=\"https://i.imgur.com/AdoDfYh.png\">\n如果想自己定義關聯的 table name：</p>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">model Post {\nid         Int         @id @default(autoincrement())\ncategories Category[]  @relation(&quot;MyRelationTable&quot;)\n}\nmodel Category {\nid    Int     @id @default(autoincrement())\nposts Post[]  @relation(&quot;MyRelationTable&quot;)\n}</code>\n        </deckgo-highlight-code>\n<p><img src=\"https://i.imgur.com/rikFBeb.png\"></p>\n</li>\n<li>\n<p>Explicit：要定義額外的 Model 代表關聯，<code>@relation</code> 集中在這 Model，以雙表 id 組合在此 Model 的 id，並且可以額外加上資訊如建立關聯的時間</p>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">model Post {\nid         Int                 @id @default(autoincrement())\ntitle      String\ncategories CategoriesOnPosts[]\n}\nmodel Category {\nid    Int                 @id @default(autoincrement())\nname  String\nposts CategoriesOnPosts[]\n}\nmodel CategoriesOnPosts {\npost        Post     @relation(fields: [postId], references: [id])\npostId      Int\ncategory    Category @relation(fields: [categoryId], references: [id])\ncategoryId  Int\ncreatedAt   DateTime @default(now())\n@@id([postId, categoryId])\n}</code>\n        </deckgo-highlight-code>\n<p><img src=\"https://i.imgur.com/LTAUsRm.png\">\n<img src=\"https://i.imgur.com/V6Ier26.png\"></p>\n</li>\n<li><a href=\"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema/relations#conventions-for-relation-tables-in-implicit-m-n-relations\" target=\"_blank\" rel=\"nofollow\">如果是 introspection generate prisma client，在那前 MySQL 寫表多對多的關聯可參考這</a>\n再一個範例：</li>\n</ul>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">model AnotherPost {\n  authorFirstName String?\n  authorLastName  String?\n  id              Int          @default(autoincrement()) @id\n  title           String?\n  AnotherUser     AnotherUser? @relation(fields: [authorFirstName, authorLastName], references: [firstName, lastName])\n  @@index([authorFirstName, authorLastName], name: &quot;authorFirstName&quot;)\n}\nmodel AnotherUser {\n  firstName   String?\n  id          Int           @default(autoincrement()) @id\n  lastName    String?\n  AnotherPost AnotherPost[]\n  @@unique([firstName, lastName], name: &quot;firstName&quot;)\n}\nmodel Post {\n  authorId Int?\n  id       Int     @default(autoincrement()) @id\n  title    String?\n  User     User?   @relation(fields: [authorId], references: [id]) # 多方關聯父依據\n  @@index([authorId], name: &quot;author&quot;)\n}\nmodel User {\n  id   Int     @default(autoincrement()) @id\n  name String?\n  Post Post[]\n}</code>\n        </deckgo-highlight-code>\n<h3>Self-relations</h3>\n<h4><a href=\"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema/relations#one-to-one-self-relations\" target=\"_blank\" rel=\"nofollow\">1-1 Self Relations</a></h4>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">model User {\n  id             Int     @default(autoincrement()) @id\n  name           String?\n  successorId Int?\n  successor   User?   @relation(&quot;BlogOwnerHistory&quot;, fields: [successorId], references: [id])\n  predecessor User?   @relation(&quot;BlogOwnerHistory&quot;)\n}</code>\n        </deckgo-highlight-code>\n<h4><a href=\"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema/relations#one-to-many-self-relations\" target=\"_blank\" rel=\"nofollow\">1-n Self Relations</a></h4>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">model User {\n  id       Int      @id @default(autoincrement())\n  name     String?\n  teacherId Int?\n  teacher  User?     @relation(&quot;TeacherStudents&quot;, fields: [teacherId], references: [id])\n  students User[]   @relation(&quot;TeacherStudents&quot;)\n}</code>\n        </deckgo-highlight-code>\n<h4><a href=\"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema/relations#many-to-many-self-relations\" target=\"_blank\" rel=\"nofollow\">m-n Self Relations (Implicit)</a></h4>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">model User {\n  id          Int      @id @default(autoincrement())\n  name        String?\n  followedBy  User[]   @relation(&quot;UserFollows&quot;, references: [id])\n  following   User[]   @relation(&quot;UserFollows&quot;, references: [id])\n}</code>\n        </deckgo-highlight-code>\n<h5>Ex.</h5>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">model User {\n  id          Int      @id @default(autoincrement())\n  name        String?\n  husband     User?    @relation(&quot;MarriagePartners&quot;)\n  wife        User     @relation(&quot;MarriagePartners&quot;)\n  teacher     User?    @relation(&quot;TeacherStudents&quot;)\n  students    User[]   @relation(&quot;TeacherStudents&quot;)\n  followedBy  User[]   @relation(&quot;UserFollows&quot;)\n  following   User[]   @relation(&quot;UserFollows&quot;)\n}</code>\n        </deckgo-highlight-code>\n<h3>Disambiguating relations</h3>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">model User {\n  id           Int     @id @default(autoincrement())\n  name         String?\n  writtenPosts Post[]  @relation(&quot;WrittenPosts&quot;)\n  pinnedPost   Post?   @relation(&quot;PinnedPost&quot;)\n}\nmodel Post {\n  id          Int     @id @default(autoincrement())\n  title       String?\n  author      User    @relation(&quot;WrittenPosts&quot;, fields: [authorId], references: [id])\n  authorId    Int\n  pinnedBy    User?   @relation(name: &quot;PinnedPost&quot;, fields: [pinnedById], references: [id])\n  pinnedById  Int?\n}</code>\n        </deckgo-highlight-code>\n<h2>Cascading deletes</h2>\n<p>得以定義當然除一筆 data 時，怎麼處理與它關聯的其他 table 的資料 (<a href=\"https://www.prisma.io/docs/guides/database-workflows/cascading-deletes/mysql#6-introspect-your-database-with-prisma\" target=\"_blank\" rel=\"nofollow\">MySQL</a>)\n但遺憾目前沒有方法能以 prisma schema 同概念的創建 table\n<a href=\"https://github.com/prisma/prisma/discussions/2149\" target=\"_blank\" rel=\"nofollow\">https://github.com/prisma/prisma/discussions/2149</a></p>\n<h2>定義好後記得要 <code>npx prisma generate</code> 才會產生／更新 Prisma Client</h2>\n<h1>Prisma Client CRUD (Resolver 內)</h1>\n<p>🔆 重點：<a href=\"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/relation-queries\" target=\"_blank\" rel=\"nofollow\">Relation queries</a>，nesting 的寫法</p>\n<h2>☼ Read</h2>\n<h3>findOne</h3>\n<ul>\n<li>return object 或 null</li>\n<li>要搭配 <code>where</code>，且搜尋條件要讓結果必成唯一，例如 data model attribute 有 <code>@id</code>, <code>@unique</code> 修飾的 field</li>\n<li>\n<p><a href=\"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/crud#type\" target=\"_blank\" rel=\"nofollow\">還有 <code>select</code>, <code>include</code> 可以使用</a>（在其他 crud method 中也是相同用法），例如</p>\n<ul>\n<li>\n<p>select: 指定要被 return 的 properties（但好像用不太到）</p>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\"># schema.prisma\nmodel User {\nid      Int      @id @default(autoincrement())\nname    String\nposts   Post[]\n}\nmodel Post {\nid      Int     @id @default(autoincrement())\nauthor  User    @relation(fields: [userId], references: [id])\nauthorId  Int\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const result = await prisma.user.findMany({\nselect: {\nid: true,\nname: true,\nposts: {\n  include: {\n    author: true,\n  },\n},\n},\n})</code>\n        </deckgo-highlight-code>\n</li>\n<li>include: load relations 的部分，沒有給 true 的話會得到 null</li>\n<li><code>@relation</code> 類似建立 foreign key 關聯別的 table，teacher 就像把關聯到的部分也綁在這張 table 可以隨時 include 載入得以取用</li>\n</ul>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">    # schema.prisma\nmodel Course {\n  id             Int              @default(autoincrement()) @id\n  title          String\n  desc           String?\n  teacherId      Int              @map(name: &quot;teacher_id&quot;)\n  teacher        User             @relation(fields: [teacherId], references: [id])\n\n  @@map(name: &quot;course&quot;)\n  @@unique([title, teacherId])\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const result = await prisma.course.findOne({\n  where: { id: courseId },\n  include: { teacher: true },\n});</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>單一 id <code>where</code></p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const result = await prisma.user.findOne({\nwhere: {\n  id: 42,\n},\n});</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>組合 id <code>where</code></p>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\"># schema.prisma\nmodel User {\nfirstName String\nlastName  String\n@@id([firstName, lastName])\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const result = await prisma.user.findOne({\nwhere: {\n  firstName_lastName: {\n    firstName: &#39;Alice&#39;,\n    lastName: &#39;Smith&#39;,\n  },\n},\n});\n\n// 或是\nconst result = await prisma.user.findOne({\nwhere: {\n  firstName: &#39;Alice&#39;,\n  lastName: &#39;Smith&#39;,\n},\n});\n\n// 或是（這種寫法才有 filter 的最大彈性）\n// 預設就是 AND 所以上兩例不用給 AND，其他還可以用 NOT, OR\nconst result = await prisma.user.findOne({\nwhere: {\n  AND: [{ firstName: { equals: &#39;Alice&#39; } }, { lastName: { equals: &#39;Smith&#39; } }],\n},\n});</code>\n        </deckgo-highlight-code>\n<p>先介紹一下 <code>where</code> 的用法：作為 filter</p>\n</li>\n</ul>\n<h3>- where</h3>\n<ul>\n<li>依據 property 的型別可接受的 <a href=\"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/filtering\" target=\"_blank\" rel=\"nofollow\">filter types 不太一樣，請參考這裡</a>，例如 <code>lt</code>, <code>lte</code>, <code>gt</code>, <code>gte</code>, <code>contains</code>, <code>startsWith</code>, <code>endsWith</code>, <code>equals</code> 等\n用法簡言之就是：where 條件某個/list(AND/OR/NOT) property 然後給 filter type 和 filter 值，幾乎在任何你想得到的篩選場景都可以插入個 where 來實踐！\n（但寫法真的滿多種，就得靠練習練出 sense 了(?)\n請搭配參閱 <a href=\"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/filtering#filter-on-related-records\" target=\"_blank\" rel=\"nofollow\">filtering documentation</a></li>\n<li>\n<p>來試著講看看下面這段是在篩什麼？</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const result = await prisma.post.findMany({\nwhere: {\n  OR: [\n    {\n      title: {\n        contains: &#39;Prisma&#39;,\n      },\n    },\n    {\n      title: {\n        contains: &#39;databases&#39;,\n      },\n    },\n  ],\n  NOT: {\n    title: {\n      contains: &#39;SQL&#39;,\n    },\n  },\n  user: {\n    NOT: {\n      email: {\n        contains: &#39;meeting&#39;,\n      },\n    },\n  },\n},\ninclude: {\n  user: true,\n},\n});</code>\n        </deckgo-highlight-code>\n<p>上面代表：取得所有 title 包含 \"Prisma\" 或 \"databases\" 但不包含 \"SQL\"、且關聯的 user 的 email 不包含 \"meeting\" 的所有 post list</p>\n</li>\n<li>\n<p>關聯 record 的 filter</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const result = await prisma.post.findMany({\nwhere: {\n  user: {\n    email: {\n      equals: &#39;sarah@prisma.io&#39;,\n    },\n  },\n},\n});</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p><code>where</code> 除了 <code>AND</code>, <code>OR</code>, <code>NOT</code>，也可以搭配 <code>some</code>, <code>every</code>, <code>none</code> 來做條件</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const result = await prisma.user.findMany({\nwhere: {\n  post: {\n    every: {\n      published: true,\n    },\n    some: {\n      content: {\n        contains: &#39;Prisma&#39;,\n      },\n    },\n  },\n},\n});</code>\n        </deckgo-highlight-code>\n<p>上面代表：取得所有 post 都 published、且其中有內容含有 \"Prisma\" 的 user list</p>\n</li>\n<li>\n<p><code>include</code> 中使用 <code>where</code></p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const result = await prisma.user.findMany({\nwhere: {\n  Post: {\n    some: {\n      published: false,\n    },\n  },\n},\ninclude: {\n  Post: {\n    where: {\n      published: false,\n    },\n  },\n},\n});</code>\n        </deckgo-highlight-code>\n<p>上面代表：取得所有至少一篇 post 沒有 publish 的，且 include 所有 publish 的 post list 的 user 的 list</p>\n</li>\n<li>\n<p><code>select</code> 中使用</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const result = await prisma.user.findMany({\nwhere: {\n  email: {\n    contains: &#39;prisma.io&#39;,\n  },\n},\nselect: {\n  posts: {\n    where: {\n      published: false,\n    },\n    select: {\n      title: true,\n    },\n  },\n},\n});</code>\n        </deckgo-highlight-code>\n<p>上面代表：取得所有 email 含有 \"prisma.io\" 的 user 的符合未 publish 的 post list\n其實換個角度以 prisma.post.findMany 開頭也可以寫出同概念的 query</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const result = await prisma.post.findMany({\nwhere: {\n  published: false,\n  user: {\n    email: {\n      contains: &#39;prisma.io&#39;,\n    },\n  },\n},\nselect: {\n  title: true,\n},\n});</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h3>findMany</h3>\n<ul>\n<li>return list</li>\n<li>\n<p><a href=\"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/crud#type-1\" target=\"_blank\" rel=\"nofollow\">除了 <code>select</code>, <code>include</code> 還有得以 paginate, filter, 和 order 的用法</a></p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const result = await prisma.user.findMany({\nwhere: {\n  email: {\n    endsWith: &#39;prisma.io&#39;,\n  },\n},\n});</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const result = await prisma.post.findMany({\nwhere: {\n  date_created: {\n    gte: new Date(&#39;2020-03-19T14:21:00+0200&#39;) /* Includes time offset for UTC */,\n  },\n},\n});</code>\n        </deckgo-highlight-code>\n<ul>\n<li>排序：<code>orderBy</code> field <code>asc</code>（小到大） 或 <code>desc</code>（大到小）</li>\n<li><code>take</code> 取 list 前 n 筆或 <code>cursor</code> 後 n 筆</li>\n<li><code>skip</code> 跳前過 n 筆</li>\n<li><code>cursor</code> 指一個 list 的位置，通常是 id 或 unique value（補範例）</li>\n</ul>\n</li>\n</ul>\n<h3>- distinct</h3>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\"># schema.prisma\ngenerator client {\n  provider = &quot;prisma-client-js&quot;\n  previewFeatures = [&quot;distinct&quot;] # 要多這行設定才可使用\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const result = await prisma.user.findMany({\n  distinct: [&#39;birthday&#39;],\n});</code>\n        </deckgo-highlight-code>\n<h2>☼ Create</h2>\n<h3>create</h3>\n<ul>\n<li>\n<p>必須給 <code>data</code>（通常就是定義的 input object 那包）</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const user = await prisma.user.create({\ndata: { email: &#39;alice@prisma.io&#39; },\n});</code>\n        </deckgo-highlight-code>\n<ul>\n<li>所以當 schema 定義傳入的是 data: XXXInput 時，resolver 第二個參數得的 data 可直接塞給 create</li>\n</ul>\n</li>\n<li>return object，一樣可以 <code>select</code>、<code>include</code></li>\n<li>關聯的 type（別張 table）可以同時一起新增</li>\n<li>\n<p>範例</p>\n<ul>\n<li>\n<p>一對多時的同時新增：假設新增 user 同時新增他關聯的多個 post</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const user = await prisma.user.create({\ndata: {\nemail: &#39;alice@prisma.io&#39;,\nposts: {\n  create: [{ title: &#39;This is my first post&#39; }, { title: &#39;Here comes a second post&#39; }],\n},\n},\n});</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>一對多時的同時新增：新增已存在的 user post</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const user = await prisma.post.create({\ndata: {\ntitle: &#39;Hello World&#39;,\nauthor: {\n  connect: { email: &#39;alice@prisma.io&#39; },\n},\n},\n});</code>\n        </deckgo-highlight-code>\n<p><code>connect</code> 的 property 一樣必須是 id 或 unique，若找無 query 會失敗，想避免 connect 這種失敗可以使用 <code>connectOrCreate</code>（後面補充）\n上面 code 也可以改以 user update 的角度寫：</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const user = await prisma.user.update({\nwhere: { email: &#39;alice@prisma.io&#39; },\ndata: {\nposts: {\n  create: { title: &#39;Hello World&#39; },\n},\n},\n});</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n</li>\n</ul>\n<h3>- connectOrCreate</h3>\n<p>它跟 distinct 一樣是 preview feature，必須先如下新增（但我們應該也不太需要使用到）</p>\n<deckgo-highlight-code language=\"json\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\"># schema.prisma\ngenerator client {\n  provider             = &quot;prisma-client-js&quot;\n  experimentalFeatures = [&quot;connectOrCreate&quot;] # 要多這行設定才可使用\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const user = await prisma.post.create({\n  data: {\n    title: &#39;Hello World&#39;,\n    author: {\n      connectOrCreate: {\n        // connectOrCreate is a preview feature and must be enabled!\n        where: { email: &#39;alice@prisma.io&#39; },\n        create: { email: &#39;alice@prisma.io&#39; },\n      },\n    },\n  },\n});</code>\n        </deckgo-highlight-code>\n<h2>☼ Update</h2>\n<h3>update</h3>\n<p>大致和 create 用法相同。update 可同時新增/刪除/更新關聯</p>\n<ul>\n<li>必須給 <code>data</code>（要更新的部分，也是通常 input object 的那包）</li>\n<li>\n<p>必須要給 <code>where</code> 篩 id 或 unique</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const user = await prisma.user.update({\nwhere: { id: 1 },\ndata: { email: &#39;alice@prisma.io&#39; },\n});</code>\n        </deckgo-highlight-code>\n</li>\n<li>return object 或 RecordNotFound failed，一樣可以 <code>select</code>、<code>include</code></li>\n<li>關聯的 type（別張 table）可以同時一起更新</li>\n<li>\n<p>範例</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const user = await prisma.user.update({\nwhere: { email: &#39;alice@prisma.io&#39; },\ndata: {\n  posts: {\n    update: [\n      {\n        data: { published: true },\n        where: { id: 32 },\n      },\n      {\n        data: { published: true },\n        where: { id: 23 },\n      },\n    ],\n  },\n},\n});</code>\n        </deckgo-highlight-code>\n<p>也可以用 <code>upsert</code> 可以更新關聯或 create 新的（Insert 或 Update），return object\n單筆</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const user = await prisma.user.upsert({\nwhere: { id: 1 },\nupdate: { email: &#39;alice@prisma.io&#39; },\ncreate: { email: &#39;alice@prisma.io&#39; },\n});</code>\n        </deckgo-highlight-code>\n<p>關聯多筆</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const user = await prisma.user.update({\nwhere: { email: &#39;alice@prisma.io&#39; },\ndata: {\n  posts: {\n    upsert: [\n      {\n        create: { title: &#39;This is my first post&#39; },\n        update: { title: &#39;This is my first post&#39; },\n        where: { id: 32 },\n      },\n      {\n        create: { title: &#39;This is mt second post&#39; },\n        update: { title: &#39;This is mt second post&#39; },\n        where: { id: 23 },\n      },\n    ],\n  },\n},\n});</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const user = await prisma.user.update({\nwhere: { email: &#39;alice@prisma.io&#39; },\ndata: {\n  posts: {\n    delete: [{ id: 34 }, { id: 36 }],\n  },\n},\n});</code>\n        </deckgo-highlight-code>\n<p>還有 disconnect 關聯的用法</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const user = await prisma.user.update({\nwhere: { email: &#39;alice@prisma.io&#39; },\ndata: {\n  posts: {\n    disconnect: [{ id: 44 }, { id: 46 }],\n  },\n},\n});</code>\n        </deckgo-highlight-code>\n<p>重新指定關聯的 posts</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const user = await prisma.user.update({\nwhere: { email: &#39;alice@prisma.io&#39; },\ndata: {\n  posts: {\n    set: [{ id: 32 }, { id: 42 }],\n  },\n},\n});</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h3>updateMany</h3>\n<ul>\n<li>必須要給 <code>data</code>（要更新的部分，也是通常 input object 的那包）</li>\n<li>批量 update 的部分 <code>where</code> 是 optional，沒給是指全部</li>\n<li>return 有 count 的 BatchPayload object</li>\n</ul>\n<h2>☼ Delete</h2>\n<h3>delete</h3>\n<ul>\n<li>\n<p>必須要給 <code>where</code> 篩 id 或 unique</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const user = await prisma.user.delete({\nwhere: { id: 1 },\n});</code>\n        </deckgo-highlight-code>\n</li>\n<li>return deleted object，一樣可以 <code>select</code>、<code>include</code></li>\n</ul>\n<h3>deleteMany</h3>\n<ul>\n<li><code>where</code> 是 optional，沒給是指全部</li>\n<li>return 有 count 的 BatchPayload object</li>\n</ul>\n<h2>☼ count</h2>\n<ul>\n<li>return 有 count 的 BatchPayload object</li>\n<li>可以給 <a href=\"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/crud#reference-8\" target=\"_blank\" rel=\"nofollow\"><code>where</code>, <code>orderBy</code>, <code>skip</code>, <code>after</code>, <code>before</code>, <code>first</code>, <code>last</code></a></li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const result = await prisma.user.count({\n  where: {\n    post: {\n      some: {\n        published: true,\n      },\n    },\n  },\n});</code>\n        </deckgo-highlight-code>\n<h1>Prisma Client Pagination</h1>\n<p>簡介兩種分頁模式</p>\n<h2>Offset pagination</h2>\n<p>利用 <code>skip</code>, <code>take</code> 迅速選取到指定的頁面資料範圍（MySQL 中利用 OFFSET）\n<img src=\"https://i.imgur.com/GiMkJcJ.png\"></p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">// 假設一頁 20 筆，取第 11 頁（搭配 filter, sort）\nconst results = prisma.post.findMany({\n  skip: 200,\n  take: 20,\n  where: {\n    title: {\n      contains: &#39;Prisma&#39;,\n    },\n  },\n  orderBy: {\n    title: &#39;desc&#39;,\n  },\n});</code>\n        </deckgo-highlight-code>\n<ul>\n<li>Pros：且適用任意 sort (orderBy) 後的“不變”的結果（期間有增刪值可能會影響到）</li>\n<li>\n<p>Cons：選越後面的筆數越耗能（假設 skip 200,000），因為它一樣會從起始往後掃到你要的那段</p>\n<ul>\n<li>但一般來說像是個人部落這種的資料量不大的都還可以適用</li>\n</ul>\n</li>\n</ul>\n<h2>Cursor-based pagination</h2>\n<p>在經過 unique 且有序列的 column （EX. id 或 timestamp）排序過後的結果，取得指定點 <code>cursor</code> 前／後 limited 個數 <code>take</code> 的選取範圍結果\n可以把 cursor 當書籤的概念\n（MySQL not use OFFSET，而是查詢大於 cursor 的值）\n<img src=\"https://i.imgur.com/tVLKzmy.png\"></p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">// 上圖為例\nconst firstQueryResults = prisma.post.findMany({\n  take: 4,\n  where: {\n    title: {\n      contains: &#39;Prisma&#39;, // optional\n    },\n  },\n  orderBy: {\n    id: &#39;asc&#39;,\n  },\n});\nconst lastPostInResults = firstQueryResults[3];\nconst myCursor = lastPostInResults.id; // 29</code>\n        </deckgo-highlight-code>\n<p>呈上，指定從 cursor 位置開始取 4 個</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"monokai\" line-numbers=\"true\" >\n          <code slot=\"code\">const secondQueryResults = prisma.post.findMany({\n  take: 4, // 取後 4 筆，要改取前的話給負數即可\n  skip: 1, // 起始包含 cursor（上次選取的最後一個），會 skip 掉\n  cursor: {\n    id: myCursor, // 29\n  },\n  where: {\n    title: {\n      contains: &#39;Prisma&#39;,\n    },\n  },\n  orderBy: {\n    id: &#39;asc&#39;,\n  },\n});\nconst lastPostInResults = secondQueryResults[3];\nconst myCursor = lastPostInResults.id; // 52</code>\n        </deckgo-highlight-code>\n<p><img src=\"https://i.imgur.com/UISj2lZ.png\"></p>\n<ul>\n<li>Pros：scales（增刪值不影響）</li>\n<li>Cons：必須要排序成唯一的序列（有點抽象，但記得要拿 unique 的值來 orderBy 過就是了）。且沒辦法直接跳到指定頁，只能靠 cursor ，而 cursor 是不可預測的。</li>\n<li>適用場景：Infinite scroll、一次批次分頁完所有資料</li>\n</ul>\n<h1>Resources</h1>\n<ul>\n<li><a href=\"https://www.prisma.io/docs/getting-started/quickstart-typescript\" target=\"_blank\" rel=\"nofollow\">Prisma</a> 🔆</li>\n<li><a href=\"https://www.fooish.com/sql/constraints.html\" target=\"_blank\" rel=\"nofollow\">SQL 語法教學、Constraint 限制可以參考這邊</a></li>\n</ul>","timeToRead":19,"frontmatter":{"title":"Prisma - Schema, Data Model, Relations, Client","date":"09 Sep 2019","tags":["prisma"],"path":"blog/20190909","excerpt":"未來 Side project 可能會應用到的 SDL first 開發流程角度，簡介此可以取代傳統 ORM 的 DB toolkit。"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"blog/20170508","title":"WebForm 圖片上傳檢查","tags":["asp.net"],"excerpt":"開放上傳有可能被傳奇怪東西的風險，只檢查所看到的副檔名，謹慎來說似乎是不夠的。"}}},{"node":{"frontmatter":{"path":"blog/20170421","title":"存取遠端 EventLog","tags":["asp.net","javascript"],"excerpt":"在公司中實作一個 Event log 的查詢工具。（之後來寫了 D3 呈現查詢異常查詢的部分）"}}},{"node":{"frontmatter":{"path":"blog/20170604","title":"Web App 推播通知","tags":["asp.net"],"excerpt":"隨著行動和穿載裝置的興起，推播通知 (Push Notification) 成為維繫App用戶關係相當有力的工具"}}},{"node":{"frontmatter":{"path":"blog/20170714","title":"WebForm 使用 reCAPTCHA 驗證","tags":["asp.net"],"excerpt":"這個我不是機器人驗證一定不陌生，滿多登入畫面會看到的，剛好今天接到把圖形驗證改為 reCAPTCHA 就順手記下。"}}},{"node":{"frontmatter":{"path":"blog/20170728","title":"WebForm 註冊 JavaScript","tags":["asp.net","javascript"],"excerpt":"動態產生JS在目前公司專案中是滿常用到的小技巧，不同的用法會產生在Web Page 的不同位置而有直譯式語言的前後順序差。"}}},{"node":{"frontmatter":{"path":"blog/20180514","title":"JavaScript 中 this 指向","tags":["javascript"],"excerpt":"簡介 this 指向的六種情況。"}}},{"node":{"frontmatter":{"path":"blog/20190108","title":"JavaScript 認識非同步 Callback, Promise, async/await","tags":["javascript"],"excerpt":"Asynchronous 非同步的不同寫法的整理筆記。"}}},{"node":{"frontmatter":{"path":"blog/20190707","title":"JavaScript HTML5 Web Worker & CRA 使用踩雷","tags":["javascript"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20180521","title":"Web 常見攻擊手法","tags":["security"],"excerpt":"擁有基本的資安觀念保護好自家資料和 user 使用環境是開發人員重要的一點。"}}},{"node":{"frontmatter":{"path":"blog/20191107","title":"Javascript Event loop - macro task & micro task","tags":["javascript"],"excerpt":"介紹 Event loop 容易混淆的異步任務 macro task & micro task。"}}},{"node":{"frontmatter":{"path":"blog/20190906","title":"初探 Storybook","tags":["javascript"],"excerpt":"初探這款能夠在開發前端元件或是函式庫的同時，可以快速地建立元件各種操作模式或是樣式的工具。"}}},{"node":{"frontmatter":{"path":"blog/20210109-3","title":"REST / RESTful & HTTP Methods","tags":["javascript"],"excerpt":"簡易整理。"}}},{"node":{"frontmatter":{"path":"blog/20210109-2","title":"IntersectionObserver","tags":["javascript"],"excerpt":"公司專案有個日期連動的 scroll 優化試驗，原先是監聽 scroll。"}}},{"node":{"frontmatter":{"path":"blog/20210110","title":"Pop Quiz","tags":["javascript"],"excerpt":"記錄踩到的陷阱題。"}}},{"node":{"frontmatter":{"path":"blog/20190907","title":"GraphQL & Apollo Client","tags":["apollo"],"excerpt":"簡單介紹 React Client 端如何用 Apollo 對 GraphQL Server 做資料存取操作。"}}},{"node":{"frontmatter":{"path":"blog/20200518","title":"常用 NoSQL 雲端資料庫 - Part 1 MongoDB","tags":["mongodb"],"excerpt":"簡介 Relational/NoSQL database、mongoose ORM 寫 mongo CRUD API。"}}},{"node":{"frontmatter":{"path":"blog/20191125","title":"初探 RxJS（下）","tags":["rxjs"],"excerpt":"簡介上次未完的 RxJS 剩餘角色，和介紹目前公司後台專案使用的 redux-observable。"}}},{"node":{"frontmatter":{"path":"blog/20190906-2","title":"React Hooks - useCallback, useMemo, useRef","tags":["reactjs"],"excerpt":"JavaScript 是單執行緒、單線程的程式語言，所有的程式碼片段都會在堆疊中被執行，Web worker 相當於可讓主線程開其他 thread。"}}},{"node":{"frontmatter":{"path":"blog/20210109","title":"Response Set-Cookie 無效","tags":["apollo"],"excerpt":"記錄個之前在和同事們弄 Side project 時犯蠢遇到的問題與解決方式。"}}},{"node":{"frontmatter":{"path":"blog/20191017","title":"初探 RxJS（上）","tags":["rxjs"],"excerpt":"簡介相關的設計模式中的 Behavioral Pattern，再介紹 RxJS（先講 Observable）"}}},{"node":{"frontmatter":{"path":"blog/20200527","title":"常用 NoSQL 雲端資料庫 - Part 2 Firebase","tags":["firebase"],"excerpt":"簡介 Google 提供的後端服務平臺（BaaS）中的兩種 DB，realtime database 和 cloud firestore。"}}},{"node":{"frontmatter":{"path":"blog/20200630","title":"Express - Authentication, Authorization and Security","tags":["security","express"],"excerpt":"簡介 Express RESTful API Server 範例中 JWT 權限、授權相關。"}}},{"node":{"frontmatter":{"path":"blog/20200910","title":"Apollo Server 入門篇","tags":["apollo"],"excerpt":"快速複習去年分享的 GraphQL Schema 和 Client query 語法，並簡介如何以 Apollo Server 建立 GraphQL Server。"}}}]}},"pageContext":{"postPath":"blog/20190909","translations":[{"hreflang":"en","path":"/blog/20190909"}]}}}